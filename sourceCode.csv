hash,path,source_code
-7210449156072128497,F://JavaWorkspace//AST_Compile\src\com\nabeelkhan\ast_paerser_py4j\Code_Similarity.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.nabeelkhan.ast_paerser_py4j;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import py4j.GatewayServer;

/**
 *
 * @author NabeelShahid
 */
public class Code_Similarity {

    public static void main(String[] args) {
        GatewayServer gatewayServer = new GatewayServer(new Code_Similarity());
        gatewayServer.start();
        System.out.println(""Gateway Server Started"");
    }

    List<String> simpleName;
    HashMap<String, Integer> ast_Map;

    public Code_Similarity() {
    }

    public Code_Similarity(String file_content1) {
        Similarity_Visitor av = Similarity_Visitor.parse_java_file(file_content1.toCharArray());
        simpleName = av.getSimpleName();
        ast_Map = av.getAST_Map();
    }

    public List<String> getSimpleName() {
        return simpleName;
    }

    public HashMap<String, Integer> getAst_Map() {
        return ast_Map;
    }

}
"
-6891700925159578432,F://JavaWorkspace//AST_Compile\src\com\nabeelkhan\ast_paerser_py4j\Similarity_Visitor.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.nabeelkhan.ast_paerser_py4j;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import org.eclipse.jdt.core.compiler.IProblem;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.AssertStatement;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BlockComment;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.BreakStatement;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CharacterLiteral;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.Comment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.ConstructorInvocation;
import org.eclipse.jdt.core.dom.ContinueStatement;
import org.eclipse.jdt.core.dom.CreationReference;
import org.eclipse.jdt.core.dom.Dimension;
import org.eclipse.jdt.core.dom.DoStatement;
import org.eclipse.jdt.core.dom.EmptyStatement;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.ExportsDirective;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionMethodReference;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ForStatement;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.IntersectionType;
import org.eclipse.jdt.core.dom.Javadoc;
import org.eclipse.jdt.core.dom.LabeledStatement;
import org.eclipse.jdt.core.dom.LambdaExpression;
import org.eclipse.jdt.core.dom.LineComment;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MemberRef;
import org.eclipse.jdt.core.dom.MemberValuePair;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.MethodRef;
import org.eclipse.jdt.core.dom.MethodRefParameter;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.ModuleDeclaration;
import org.eclipse.jdt.core.dom.ModuleModifier;
import org.eclipse.jdt.core.dom.NameQualifiedType;
import org.eclipse.jdt.core.dom.NormalAnnotation;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.OpensDirective;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.ParameterizedType;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.ProvidesDirective;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.RequiresDirective;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.SuperMethodReference;
import org.eclipse.jdt.core.dom.SwitchStatement;
import org.eclipse.jdt.core.dom.SwitchCase;
import org.eclipse.jdt.core.dom.SynchronizedStatement;
import org.eclipse.jdt.core.dom.TagElement;
import org.eclipse.jdt.core.dom.TextElement;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.ThrowStatement;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.TypeMethodReference;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.UsesDirective;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.WhileStatement;
import org.eclipse.jdt.core.dom.WildcardType;

public class Similarity_Visitor extends ASTVisitor {

    private HashMap<String, Integer> AST_Map = new HashMap<>();
    private List<String> simpleName = new ArrayList<>();

    public static Similarity_Visitor parse_java_file(char[] file_content) {
        ASTParser parser = ASTParser.newParser(AST.JLS10);
        parser.setSource(file_content);
        final CompilationUnit cu;
        cu = (CompilationUnit) parser.createAST(null);

        // visit nodes of the constructed AST
        Similarity_Visitor visitor = new Similarity_Visitor();
        cu.accept(visitor);
        return visitor;
    }

    public HashMap<String, Integer> getAST_Map() {
        return AST_Map;
    }
    
    public List<String> getSimpleName() {
        return simpleName;
    }

    private boolean typeDic = false;

    private void add(String name, Object node) {
        String type = null;
        String content = node.toString().trim();
        Integer hash = content.hashCode();
        if (name != null) {
            type = name.substring(name.lastIndexOf('.') + 1);

            //to remove """" from string
            if (type.equals(""StringLiteral"")) {
                content = content.subSequence(1, content.length() - 1).toString().trim();
                hash = content.hashCode();
            }

            if (""IfStatement"".equals(type)) {
                IfStatement n = (IfStatement) node;
                this.addAST(""if("" + n.getExpression().toString() + "")"");
            }

            if (""MethodDeclaration"".equals(type)) {
                MethodDeclaration n = (MethodDeclaration) node;
                if (!simpleName.contains(content)) {
                    simpleName.add(n.getName().toString());
                }
                String para = Arrays.toString(n.parameters().toArray());
                para = para.substring(1, para.length() - 1);
                String x = null;

                String r;
                if (n.getReturnType2() == null) {
                    r = """";
                } else {
                    r = n.getReturnType2().toString();
                }
                x = r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";
                this.addAST(x);

                String modi = Arrays.toString(n.modifiers().toArray());
                modi = modi.replace(',', ' ');
                modi = modi.substring(1, modi.length() - 1);

                x = modi + "" ""
                        + r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";

                this.addAST(x);

                String exc = Arrays.toString(n.thrownExceptionTypes().toArray());
                exc = exc.replace(',', ' ');
                exc = exc.substring(1, exc.length() - 1);
                x = x + "" "" + exc;
                if (exc.length() != 0) {
                    this.addAST(x);
                }
            }

            if (type.contains(""Literal"")) {
                try {
                    Pattern.compile(""\\b"" + content + ""\\b"");
                } catch (Exception e) {
                    content = null;
                }
            }
            if (content != null && type.contains(""Literal"") || type.contains(""Name"") && typeDic) {
                if (!simpleName.contains(content)) {
                    simpleName.add(content);
                }
            }

            if (typeDic && content != null) {
                this.addAST(content);
            }
        }
    }

    public Map<CharSequence, Integer> normaliz() {
        Map<CharSequence, Integer> temp = new HashMap<>();
//        temp.putAll(this.AST_Map);
        for (Iterator i = AST_Map.keySet().iterator(); i.hasNext();) {
            String line = i.next().toString();
            String allChange = line;
            String newLine = null;
                   
            for (String sn : simpleName) {
                if (line.contains(sn)) {
                    allChange = allChange.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    newLine = line.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    if (!newLine.equals(line)) {
                        if (!temp.containsKey(newLine)) {
                            temp.put(newLine, 1);
                        } else {
                            temp.put(newLine, temp.get(newLine) + 1);
                        }
                    }
                }
            }
            if (!line.equals(allChange) && !allChange.equals(newLine)) {
                if (!temp.containsKey(allChange)) {
                    temp.put(allChange, 1);
                } else {
                    temp.put(allChange, temp.get(allChange) + 1);
                }
            }
        }
        return temp;
    }

    private void addAST(String x) {
        x = x.trim();
        if (!this.AST_Map.containsKey(x)) {
            this.AST_Map.put(x, 1);
        } else {
            this.AST_Map.put(x, this.AST_Map.get(x) + 1);
        }
    }

    @Override
    public boolean visit(CompilationUnit node) {
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclaration node) {
        this.typeDic = true;
        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodDeclaration node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(ForStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(IfStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(SwitchStatement node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SwitchCase node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WhileStatement node) {
        add(""while ("" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LambdaExpression node) {
        add(node.getClass().getName(), node);

        return true;
    }

    public boolean visit(Comment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayAccess node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Block node) {
        // 
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeDeclaration node) {
        //     
//        add(node.getClass().getName(),node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeMemberDeclaration node) {
        //   
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(AnonymousClassDeclaration node) {
        // 
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayCreation node) {
        //
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayInitializer node) {
        //     
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayType node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AssertStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Assignment node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BlockComment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BooleanLiteral node) {
        //  
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BreakStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CastExpression node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CatchClause node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CharacterLiteral node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ClassInstanceCreation node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConditionalExpression node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConstructorInvocation node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ContinueStatement node) {

        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CreationReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Dimension node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(DoStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EmptyStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnhancedForStatement node) {
        add(""for("" + node.getParameter().toString() + "" : "" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumConstantDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExportsDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ImportDeclaration node) {
        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Initializer node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InstanceofExpression node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(IntersectionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Javadoc node) {
        //System.out.println(node);
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LabeledStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LineComment node) {

        //    add(node.getClass().getName(), node);
        //   System.out.println(node.toString());
        return true;
    }

    @Override
    public boolean visit(MarkerAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberRef node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberValuePair node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRef node) {

//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRefParameter node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Modifier node) {

        //   add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleModifier node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NameQualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NormalAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NullLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NumberLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(OpensDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PackageDeclaration node) {

        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParameterizedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParenthesizedExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PostfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrefixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ProvidesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrimitiveType node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedName node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(RequiresDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ReturnStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleName node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleMemberAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleVariableDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(StringLiteral node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperConstructorInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperFieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SynchronizedStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TagElement node) {

        //     add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TextElement node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThisExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThrowStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TryStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeLiteral node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeParameter node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UnionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UsesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationFragment node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WildcardType node) {

        add(node.getClass().getName(), node);
        return true;
    }
}
"
2768030114952909000,F://JavaWorkspace//AST_Paerser_PY4J\src\main\java\com\nabeelkhan\ast_paerser_py4j\Code_Similarity.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.nabeelkhan.ast_paerser_py4j;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import py4j.GatewayServer;


/**
 *
 * @author NabeelShahid
 */
public class Code_Similarity {

    public static void main(String[] args) {
        GatewayServer gatewayServer = new GatewayServer(new Code_Similarity());
        gatewayServer.start();
        System.out.println(""Gateway Server Started"");
    }

    List<String> simpleName;
    HashMap<String, Integer> ast_Map;

    public Code_Similarity() {
    }

    public void run(String file_content1) {
        Similarity_Visitor av = Similarity_Visitor.parse_java_file(file_content1.toCharArray());
        simpleName = av.getSimpleName();
        ast_Map = av.getAST_Map();
    }

    public List<String> getSimpleName() {
        return simpleName;
    }

    public HashMap<String, Integer> getAst_Map() {
        return ast_Map;
    }

}
"
547033133866043132,F://JavaWorkspace//AST_Paerser_PY4J\src\main\java\com\nabeelkhan\ast_paerser_py4j\Similarity_Visitor.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.nabeelkhan.ast_paerser_py4j;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.jdt.core.compiler.IProblem;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.AssertStatement;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BlockComment;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.BreakStatement;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CharacterLiteral;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.Comment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.ConstructorInvocation;
import org.eclipse.jdt.core.dom.ContinueStatement;
import org.eclipse.jdt.core.dom.CreationReference;
import org.eclipse.jdt.core.dom.Dimension;
import org.eclipse.jdt.core.dom.DoStatement;
import org.eclipse.jdt.core.dom.EmptyStatement;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.ExportsDirective;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionMethodReference;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ForStatement;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.IntersectionType;
import org.eclipse.jdt.core.dom.Javadoc;
import org.eclipse.jdt.core.dom.LabeledStatement;
import org.eclipse.jdt.core.dom.LambdaExpression;
import org.eclipse.jdt.core.dom.LineComment;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MemberRef;
import org.eclipse.jdt.core.dom.MemberValuePair;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.MethodRef;
import org.eclipse.jdt.core.dom.MethodRefParameter;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.ModuleDeclaration;
import org.eclipse.jdt.core.dom.ModuleModifier;
import org.eclipse.jdt.core.dom.NameQualifiedType;
import org.eclipse.jdt.core.dom.NormalAnnotation;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.OpensDirective;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.ParameterizedType;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.ProvidesDirective;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.RequiresDirective;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.SuperMethodReference;
import org.eclipse.jdt.core.dom.SwitchStatement;
import org.eclipse.jdt.core.dom.SwitchCase;
import org.eclipse.jdt.core.dom.SynchronizedStatement;
import org.eclipse.jdt.core.dom.TagElement;
import org.eclipse.jdt.core.dom.TextElement;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.ThrowStatement;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.TypeMethodReference;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.UsesDirective;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.WhileStatement;
import org.eclipse.jdt.core.dom.WildcardType;

public class Similarity_Visitor extends ASTVisitor {

    private HashMap<String, Integer> AST_Map = new HashMap<>();
    private List<String> simpleName = new ArrayList<>();

    public static Similarity_Visitor parse_java_file(char[] file_content) {
        ASTParser parser = ASTParser.newParser(AST.JLS10);
        parser.setSource(file_content);
        final CompilationUnit cu;
     //   IProgressMonitor monitor;
		cu = (CompilationUnit)  parser.createAST(null);//parser.createAST(null);

        // visit nodes of the constructed AST
        Similarity_Visitor visitor = new Similarity_Visitor();
        cu.accept(visitor);
        return visitor;
    }

    public HashMap<String, Integer> getAST_Map() {
        return AST_Map;
    }
    
    public List<String> getSimpleName() {
        return simpleName;
    }

    private boolean typeDic = false;

    private void add(String name, Object node) {
        String type = null;
        String content = node.toString().trim();
        Integer hash = content.hashCode();
        if (name != null) {
            type = name.substring(name.lastIndexOf('.') + 1);

            //to remove """" from string
            if (type.equals(""StringLiteral"")) {
                content = content.subSequence(1, content.length() - 1).toString().trim();
                hash = content.hashCode();
            }

            if (""IfStatement"".equals(type)) {
                IfStatement n = (IfStatement) node;
                this.addAST(type+"":-:""+""if("" + n.getExpression().toString() + "")"");
            }

            if (""MethodDeclaration"".equals(type)) {
                MethodDeclaration n = (MethodDeclaration) node;
                if (!simpleName.contains(content)) {
                    simpleName.add(n.getName().toString());
                }
                String para = Arrays.toString(n.parameters().toArray());
                para = para.substring(1, para.length() - 1);
                String x = null;

                String r;
                if (n.getReturnType2() == null) {
                    r = """";
                } else {
                    r = n.getReturnType2().toString();
                }
                x = r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";
                this.addAST(type+"":-:""+x);

                String modi = Arrays.toString(n.modifiers().toArray());
                modi = modi.replace(',', ' ');
                modi = modi.substring(1, modi.length() - 1);

                x = modi + "" ""
                        + r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";

                this.addAST(x);

                String exc = Arrays.toString(n.thrownExceptionTypes().toArray());
                exc = exc.replace(',', ' ');
                exc = exc.substring(1, exc.length() - 1);
                x = x + "" "" + exc;
                if (exc.length() != 0) {
                    this.addAST(x);
                }
            }

            if (type.contains(""Literal"")) {
                try {
                    Pattern.compile(""\\b"" + content + ""\\b"");
                } catch (Exception e) {
                    content = null;
                }
            }
            if (content != null && type.contains(""Literal"") || type.contains(""Name"") && typeDic) {
                if (!simpleName.contains(content)) {
                    simpleName.add(content);
                }
            }

            if (typeDic && content != null) {
                this.addAST(type+"":-:""+content);
            }
        }
    }

    public Map<CharSequence, Integer> normaliz() {
        Map<CharSequence, Integer> temp = new HashMap<>();
//        temp.putAll(this.AST_Map);
        for (Iterator i = AST_Map.keySet().iterator(); i.hasNext();) {
            String line = i.next().toString();
            String allChange = line;
            String newLine = null;
                   
            for (String sn : simpleName) {
                if (line.contains(sn)) {
                    allChange = allChange.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    newLine = line.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    if (!newLine.equals(line)) {
                        if (!temp.containsKey(newLine)) {
                            temp.put(newLine, 1);
                        } else {
                            temp.put(newLine, temp.get(newLine) + 1);
                        }
                    }
                }
            }
            if (!line.equals(allChange) && !allChange.equals(newLine)) {
                if (!temp.containsKey(allChange)) {
                    temp.put(allChange, 1);
                } else {
                    temp.put(allChange, temp.get(allChange) + 1);
                }
            }
        }
        return temp;
    }

    private void addAST(String x) {
        x = x.trim();
        if (!this.AST_Map.containsKey(x)) {
            this.AST_Map.put(x, 1);
        } else {
            this.AST_Map.put(x, this.AST_Map.get(x) + 1);
        }
    }

    @Override
    public boolean visit(CompilationUnit node) {
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclaration node) {
        this.typeDic = true;
        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodDeclaration node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(ForStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(IfStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(SwitchStatement node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SwitchCase node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WhileStatement node) {
        add(""while ("" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LambdaExpression node) {
        add(node.getClass().getName(), node);

        return true;
    }

    public boolean visit(Comment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayAccess node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Block node) {
        // 
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeDeclaration node) {
        //     
//        add(node.getClass().getName(),node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeMemberDeclaration node) {
        //   
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(AnonymousClassDeclaration node) {
        // 
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayCreation node) {
        //
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayInitializer node) {
        //     
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayType node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AssertStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Assignment node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BlockComment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BooleanLiteral node) {
        //  
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BreakStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CastExpression node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CatchClause node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CharacterLiteral node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ClassInstanceCreation node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConditionalExpression node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConstructorInvocation node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ContinueStatement node) {

        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CreationReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Dimension node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(DoStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EmptyStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnhancedForStatement node) {
        add(""for("" + node.getParameter().toString() + "" : "" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumConstantDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExportsDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ImportDeclaration node) {
        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Initializer node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InstanceofExpression node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(IntersectionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Javadoc node) {
        //System.out.println(node);
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LabeledStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LineComment node) {

        //    add(node.getClass().getName(), node);
        //   System.out.println(node.toString());
        return true;
    }

    @Override
    public boolean visit(MarkerAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberRef node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberValuePair node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRef node) {

//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRefParameter node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Modifier node) {

        //   add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleModifier node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NameQualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NormalAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NullLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NumberLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(OpensDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PackageDeclaration node) {

        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParameterizedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParenthesizedExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PostfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrefixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ProvidesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrimitiveType node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedName node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(RequiresDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ReturnStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleName node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleMemberAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleVariableDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(StringLiteral node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperConstructorInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperFieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SynchronizedStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TagElement node) {

        //     add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TextElement node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThisExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThrowStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TryStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeLiteral node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeParameter node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UnionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UsesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationFragment node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WildcardType node) {

        add(node.getClass().getName(), node);
        return true;
    }
}
"
-4886371096352373361,F://JavaWorkspace//AST_PY4J_Compiler\src\Code_Similarity.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.HashMap;
import java.util.List;

import py4j.GatewayServer;

/**
 *
 * @author NabeelShahid
 */
public class Code_Similarity {
	
    public static void main(String[] args) {
        GatewayServer gatewayServer = new GatewayServer(new Code_Similarity());
        gatewayServer.start();
        System.out.println(""Gateway Server Started"");
    }

    List<String> simpleName;
    HashMap<String, Integer> ast_Map;

    public Code_Similarity() {
    }

    public void run(String file_content1) {
        Similarity_Visitor av = Similarity_Visitor.parse_java_file(file_content1.toCharArray());
        simpleName = av.getSimpleName();
        ast_Map = av.getAST_Map();
    }

    public List<String> getSimpleName() {
        return simpleName;
    }

    public HashMap<String, Integer> getAst_Map() {
        return ast_Map;
    }

}
"
173511243414467861,F://JavaWorkspace//AST_PY4J_Compiler\src\Similarity_Visitor.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.AssertStatement;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BlockComment;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.BreakStatement;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CharacterLiteral;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.Comment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.ConstructorInvocation;
import org.eclipse.jdt.core.dom.ContinueStatement;
import org.eclipse.jdt.core.dom.CreationReference;
import org.eclipse.jdt.core.dom.Dimension;
import org.eclipse.jdt.core.dom.DoStatement;
import org.eclipse.jdt.core.dom.EmptyStatement;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.ExportsDirective;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionMethodReference;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ForStatement;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.IntersectionType;
import org.eclipse.jdt.core.dom.Javadoc;
import org.eclipse.jdt.core.dom.LabeledStatement;
import org.eclipse.jdt.core.dom.LambdaExpression;
import org.eclipse.jdt.core.dom.LineComment;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MemberRef;
import org.eclipse.jdt.core.dom.MemberValuePair;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.MethodRef;
import org.eclipse.jdt.core.dom.MethodRefParameter;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.ModuleDeclaration;
import org.eclipse.jdt.core.dom.ModuleModifier;
import org.eclipse.jdt.core.dom.NameQualifiedType;
import org.eclipse.jdt.core.dom.NormalAnnotation;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.OpensDirective;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.ParameterizedType;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.ProvidesDirective;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.RequiresDirective;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.SuperMethodReference;
import org.eclipse.jdt.core.dom.SwitchStatement;
import org.eclipse.jdt.core.dom.SwitchCase;
import org.eclipse.jdt.core.dom.SynchronizedStatement;
import org.eclipse.jdt.core.dom.TagElement;
import org.eclipse.jdt.core.dom.TextElement;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.ThrowStatement;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.TypeMethodReference;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.UsesDirective;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.WhileStatement;
import org.eclipse.jdt.core.dom.WildcardType;

public class Similarity_Visitor extends ASTVisitor {

    private HashMap<String, Integer> AST_Map = new HashMap<>();
    private List<String> simpleName = new ArrayList<>();

    public static Similarity_Visitor parse_java_file(char[] file_content) {
        ASTParser parser = ASTParser.newParser(AST.JLS10);
        parser.setSource(file_content);
        final CompilationUnit cu;
        //IProgressMonitor monitor = null;
		cu = (CompilationUnit)  parser.createAST(null);//parser.createAST(null);

        // visit nodes of the constructed AST
        Similarity_Visitor visitor = new Similarity_Visitor();
        cu.accept(visitor);
        return visitor;
    }

    public HashMap<String, Integer> getAST_Map() {
        return AST_Map;
    }
    
    public List<String> getSimpleName() {
        return simpleName;
    }

    private boolean typeDic = false;

    private void add(String name, Object node) {
        String type = null;
        String content = node.toString().trim();
        Integer hash = content.hashCode();
        if (name != null) {
            type = name.substring(name.lastIndexOf('.') + 1);

            //to remove """" from string
            if (type.equals(""StringLiteral"")) {
                content = content.subSequence(1, content.length() - 1).toString().trim();
                hash = content.hashCode();
            }

            if (""IfStatement"".equals(type)) {
                IfStatement n = (IfStatement) node;
                this.addAST(type+"":-:""+""if("" + n.getExpression().toString() + "")"");
            }

            if (""MethodDeclaration"".equals(type)) {
                MethodDeclaration n = (MethodDeclaration) node;
                if (!simpleName.contains(content)) {
                    simpleName.add(n.getName().toString());
                }
                String para = Arrays.toString(n.parameters().toArray());
                para = para.substring(1, para.length() - 1);
                String x = null;

                String r;
                if (n.getReturnType2() == null) {
                    r = """";
                } else {
                    r = n.getReturnType2().toString();
                }
                x = r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";
                this.addAST(type+"":-:""+x);

                String modi = Arrays.toString(n.modifiers().toArray());
                modi = modi.replace(',', ' ');
                modi = modi.substring(1, modi.length() - 1);

                x = modi + "" ""
                        + r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";

                this.addAST(x);

                String exc = Arrays.toString(n.thrownExceptionTypes().toArray());
                exc = exc.replace(',', ' ');
                exc = exc.substring(1, exc.length() - 1);
                x = x + "" "" + exc;
                if (exc.length() != 0) {
                    this.addAST(x);
                }
            }

            if (type.contains(""Literal"")) {
                try {
                    Pattern.compile(""\\b"" + content + ""\\b"");
                } catch (Exception e) {
                    content = null;
                }
            }
            if (content != null && type.contains(""Literal"") || type.contains(""Name"") && typeDic) {
                if (!simpleName.contains(content)) {
                    simpleName.add(content);
                }
            }

            if (typeDic && content != null) {
                this.addAST(type+"":-:""+content);
            }
        }
    }

    public Map<CharSequence, Integer> normaliz() {
        Map<CharSequence, Integer> temp = new HashMap<>();
//        temp.putAll(this.AST_Map);
        for (Iterator i = AST_Map.keySet().iterator(); i.hasNext();) {
            String line = i.next().toString();
            String allChange = line;
            String newLine = null;
                   
            for (String sn : simpleName) {
                if (line.contains(sn)) {
                    allChange = allChange.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    newLine = line.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    if (!newLine.equals(line)) {
                        if (!temp.containsKey(newLine)) {
                            temp.put(newLine, 1);
                        } else {
                            temp.put(newLine, temp.get(newLine) + 1);
                        }
                    }
                }
            }
            if (!line.equals(allChange) && !allChange.equals(newLine)) {
                if (!temp.containsKey(allChange)) {
                    temp.put(allChange, 1);
                } else {
                    temp.put(allChange, temp.get(allChange) + 1);
                }
            }
        }
        return temp;
    }

    private void addAST(String x) {
        x = x.trim();
        if (!this.AST_Map.containsKey(x)) {
            this.AST_Map.put(x, 1);
        } else {
            this.AST_Map.put(x, this.AST_Map.get(x) + 1);
        }
    }

    @Override
    public boolean visit(CompilationUnit node) {
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclaration node) {
        this.typeDic = true;
        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodDeclaration node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(ForStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(IfStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(SwitchStatement node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SwitchCase node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WhileStatement node) {
        add(""while ("" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LambdaExpression node) {
        add(node.getClass().getName(), node);

        return true;
    }

    public boolean visit(Comment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayAccess node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Block node) {
        // 
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeDeclaration node) {
        //     
//        add(node.getClass().getName(),node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeMemberDeclaration node) {
        //   
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(AnonymousClassDeclaration node) {
        // 
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayCreation node) {
        //
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayInitializer node) {
        //     
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayType node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AssertStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Assignment node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BlockComment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BooleanLiteral node) {
        //  
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BreakStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CastExpression node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CatchClause node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CharacterLiteral node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ClassInstanceCreation node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConditionalExpression node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConstructorInvocation node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ContinueStatement node) {

        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CreationReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Dimension node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(DoStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EmptyStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnhancedForStatement node) {
        add(""for("" + node.getParameter().toString() + "" : "" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumConstantDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExportsDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ImportDeclaration node) {
        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Initializer node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InstanceofExpression node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(IntersectionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Javadoc node) {
        //System.out.println(node);
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LabeledStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LineComment node) {

        //    add(node.getClass().getName(), node);
        //   System.out.println(node.toString());
        return true;
    }

    @Override
    public boolean visit(MarkerAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberRef node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberValuePair node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRef node) {

//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRefParameter node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Modifier node) {

        //   add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleModifier node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NameQualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NormalAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NullLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NumberLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(OpensDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PackageDeclaration node) {

        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParameterizedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParenthesizedExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PostfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrefixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ProvidesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrimitiveType node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedName node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(RequiresDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ReturnStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleName node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleMemberAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleVariableDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(StringLiteral node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperConstructorInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperFieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SynchronizedStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TagElement node) {

        //     add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TextElement node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThisExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThrowStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TryStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeLiteral node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeParameter node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UnionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UsesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationFragment node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WildcardType node) {

        add(node.getClass().getName(), node);
        return true;
    }
}
"
8289095168319897873,F://JavaWorkspace//AST_PY4J_Compiler\src\Test\Similarity_Visitor.java,"package Test;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.AssertStatement;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BlockComment;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.BreakStatement;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CharacterLiteral;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.Comment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.ConstructorInvocation;
import org.eclipse.jdt.core.dom.ContinueStatement;
import org.eclipse.jdt.core.dom.CreationReference;
import org.eclipse.jdt.core.dom.Dimension;
import org.eclipse.jdt.core.dom.DoStatement;
import org.eclipse.jdt.core.dom.EmptyStatement;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.ExportsDirective;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionMethodReference;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ForStatement;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.IntersectionType;
import org.eclipse.jdt.core.dom.Javadoc;
import org.eclipse.jdt.core.dom.LabeledStatement;
import org.eclipse.jdt.core.dom.LambdaExpression;
import org.eclipse.jdt.core.dom.LineComment;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MemberRef;
import org.eclipse.jdt.core.dom.MemberValuePair;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.MethodRef;
import org.eclipse.jdt.core.dom.MethodRefParameter;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.ModuleDeclaration;
import org.eclipse.jdt.core.dom.ModuleModifier;
import org.eclipse.jdt.core.dom.NameQualifiedType;
import org.eclipse.jdt.core.dom.NormalAnnotation;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.OpensDirective;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.ParameterizedType;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.ProvidesDirective;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.RequiresDirective;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.SuperMethodReference;
import org.eclipse.jdt.core.dom.SwitchStatement;
import org.eclipse.jdt.core.dom.SwitchCase;
import org.eclipse.jdt.core.dom.SynchronizedStatement;
import org.eclipse.jdt.core.dom.TagElement;
import org.eclipse.jdt.core.dom.TextElement;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.ThrowStatement;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.TypeMethodReference;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.UsesDirective;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.WhileStatement;
import org.eclipse.jdt.core.dom.WildcardType;

public class Similarity_Visitor extends ASTVisitor {

    private HashMap<String, Integer> AST_Map = new HashMap<>();
    private List<String> simpleName = new ArrayList<>();

    public static Similarity_Visitor parse_java_file(char[] file_content) {
        ASTParser parser = ASTParser.newParser(AST.JLS10);
        parser.setSource(file_content);
        final CompilationUnit cu;
        //IProgressMonitor monitor = null;
		cu = (CompilationUnit)  parser.createAST(null);//parser.createAST(null);

        // visit nodes of the constructed AST
        Similarity_Visitor visitor = new Similarity_Visitor();
        cu.accept(visitor);
        return visitor;
    }

    public HashMap<String, Integer> getAST_Map() {
        return AST_Map;
    }
    
    public List<String> getSimpleName() {
        return simpleName;
    }

    private boolean typeDic = false;

    private void add(String name, Object node) {
        String type = null;
        String content = node.toString().trim();
        Integer hash = content.hashCode();
        if (name != null) {
            type = name.substring(name.lastIndexOf('.') + 1);

            //to remove """" from string
            if (type.equals(""StringLiteral"")) {
                content = content.subSequence(1, content.length() - 1).toString().trim();
                hash = content.hashCode();
            }

            if (""IfStatement"".equals(type)) {
                IfStatement n = (IfStatement) node;
                this.addAST(type+"":-:""+""if("" + n.getExpression().toString() + "")"");
            }

            if (""MethodDeclaration"".equals(type)) {
                MethodDeclaration n = (MethodDeclaration) node;
                if (!simpleName.contains(content)) {
                    simpleName.add(n.getName().toString());
                }
                String para = Arrays.toString(n.parameters().toArray());
                para = para.substring(1, para.length() - 1);
                String x = null;

                String r;
                if (n.getReturnType2() == null) {
                    r = """";
                } else {
                    r = n.getReturnType2().toString();
                }
                x = r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";
                this.addAST(type+"":-:""+x);

                String modi = Arrays.toString(n.modifiers().toArray());
                modi = modi.replace(',', ' ');
                modi = modi.substring(1, modi.length() - 1);

                x = modi + "" ""
                        + r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";

                this.addAST(x);

                String exc = Arrays.toString(n.thrownExceptionTypes().toArray());
                exc = exc.replace(',', ' ');
                exc = exc.substring(1, exc.length() - 1);
                x = x + "" "" + exc;
                if (exc.length() != 0) {
                    this.addAST(x);
                }
            }

            if (type.contains(""Literal"")) {
                try {
                    Pattern.compile(""\\b"" + content + ""\\b"");
                } catch (Exception e) {
                    content = null;
                }
            }
            if (content != null && type.contains(""Literal"") || type.contains(""Name"") && typeDic) {
                if (!simpleName.contains(content)) {
                    simpleName.add(content);
                }
            }

            if (typeDic && content != null) {
                this.addAST(type+"":-:""+content);
            }
        }
    }

    public Map<CharSequence, Integer> normaliz() {
        Map<CharSequence, Integer> temp = new HashMap<>();
//        temp.putAll(this.AST_Map);
        for (Iterator i = AST_Map.keySet().iterator(); i.hasNext();) {
            String line = i.next().toString();
            String allChange = line;
            String newLine = null;
                   
            for (String sn : simpleName) {
                if (line.contains(sn)) {
                    allChange = allChange.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    newLine = line.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    if (!newLine.equals(line)) {
                        if (!temp.containsKey(newLine)) {
                            temp.put(newLine, 1);
                        } else {
                            temp.put(newLine, temp.get(newLine) + 1);
                        }
                    }
                }
            }
            if (!line.equals(allChange) && !allChange.equals(newLine)) {
                if (!temp.containsKey(allChange)) {
                    temp.put(allChange, 1);
                } else {
                    temp.put(allChange, temp.get(allChange) + 1);
                }
            }
        }
        return temp;
    }

    private void addAST(String x) {
        x = x.trim();
        if (!this.AST_Map.containsKey(x)) {
            this.AST_Map.put(x, 1);
        } else {
            this.AST_Map.put(x, this.AST_Map.get(x) + 1);
        }
    }

    @Override
    public boolean visit(CompilationUnit node) {
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclaration node) {
        this.typeDic = true;
        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodDeclaration node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(ForStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(IfStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(SwitchStatement node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SwitchCase node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WhileStatement node) {
        add(""while ("" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LambdaExpression node) {
        add(node.getClass().getName(), node);

        return true;
    }

    public boolean visit(Comment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayAccess node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Block node) {
        // 
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeDeclaration node) {
        //     
//        add(node.getClass().getName(),node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeMemberDeclaration node) {
        //   
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(AnonymousClassDeclaration node) {
        // 
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayCreation node) {
        //
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayInitializer node) {
        //     
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayType node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AssertStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Assignment node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BlockComment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BooleanLiteral node) {
        //  
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BreakStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CastExpression node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CatchClause node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CharacterLiteral node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ClassInstanceCreation node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConditionalExpression node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConstructorInvocation node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ContinueStatement node) {

        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CreationReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Dimension node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(DoStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EmptyStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnhancedForStatement node) {
        add(""for("" + node.getParameter().toString() + "" : "" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumConstantDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExportsDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ImportDeclaration node) {
        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Initializer node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InstanceofExpression node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(IntersectionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Javadoc node) {
        //System.out.println(node);
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LabeledStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LineComment node) {

        //    add(node.getClass().getName(), node);
        //   System.out.println(node.toString());
        return true;
    }

    @Override
    public boolean visit(MarkerAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberRef node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberValuePair node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRef node) {

//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRefParameter node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Modifier node) {

        //   add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleModifier node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NameQualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NormalAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NullLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NumberLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(OpensDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PackageDeclaration node) {

        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParameterizedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParenthesizedExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PostfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrefixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ProvidesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrimitiveType node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedName node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(RequiresDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ReturnStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleName node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleMemberAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleVariableDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(StringLiteral node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperConstructorInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperFieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SynchronizedStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TagElement node) {

        //     add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TextElement node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThisExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThrowStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TryStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeLiteral node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeParameter node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UnionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UsesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationFragment node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WildcardType node) {

        add(node.getClass().getName(), node);
        return true;
    }
}
"
-5433281657538006286,F://JavaWorkspace//AST_PY4J_Compiler\src\Test\Test.java,"package Test;

import java.util.HashMap;
import java.util.List;

import py4j.GatewayServer;

public class Test {

	public static void main(String[] args) {
		System.out.println(""Test"");
		GatewayServer gatewayServer = new GatewayServer(new Test());
        gatewayServer.start();
        System.out.println(""Gateway Server Started"");    
	}
	
	public void Test(){
	}

    List<String> simpleName;
    HashMap<String, Integer> ast_Map;


    public void run(String file_content1) {
        Similarity_Visitor av = Similarity_Visitor.parse_java_file(file_content1.toCharArray());
        simpleName = av.getSimpleName();
        ast_Map = av.getAST_Map();
    }

    public List<String> getSimpleName() {
        return simpleName;
    }

    public HashMap<String, Integer> getAst_Map() {
        return ast_Map;
    }


}
"
1363380023899938992,F://JavaWorkspace//capstone\.mvn\wrapper\MavenWrapperDownloader.java,"/*
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
""License""); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
*/

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.util.Properties;

public class MavenWrapperDownloader {

    /**
     * Default URL to download the maven-wrapper.jar from, if no 'downloadUrl' is provided.
     */
    private static final String DEFAULT_DOWNLOAD_URL =
            ""https://repo.maven.apache.org/maven2/io/takari/maven-wrapper/0.4.2/maven-wrapper-0.4.2.jar"";

    /**
     * Path to the maven-wrapper.properties file, which might contain a downloadUrl property to
     * use instead of the default one.
     */
    private static final String MAVEN_WRAPPER_PROPERTIES_PATH =
            "".mvn/wrapper/maven-wrapper.properties"";

    /**
     * Path where the maven-wrapper.jar will be saved to.
     */
    private static final String MAVEN_WRAPPER_JAR_PATH =
            "".mvn/wrapper/maven-wrapper.jar"";

    /**
     * Name of the property which should be used to override the default download url for the wrapper.
     */
    private static final String PROPERTY_NAME_WRAPPER_URL = ""wrapperUrl"";

    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println(""- ERROR loading '"" + MAVEN_WRAPPER_PROPERTIES_PATH + ""'"");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println(""- Downloading from: : "" + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        ""- ERROR creating output direcrory '"" + outputFile.getParentFile().getAbsolutePath() + ""'"");
            }
        }
        System.out.println(""- Downloading to: "" + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);
            System.out.println(""Done"");
            System.exit(0);
        } catch (Throwable e) {
            System.out.println(""- Error downloading"");
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }

}
"
-6727919391933927769,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\CarhireApplication.java,"package com.web.carhire;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class CarhireApplication {

	public static void main(String[] args) {
		SpringApplication.run(CarhireApplication.class, args);
	}

}
"
7998566512708537783,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\ServletInitializer.java,"package com.web.carhire;

import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;

public class ServletInitializer extends SpringBootServletInitializer {

	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(CarhireApplication.class);
	}

}
"
9017293987744700700,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\controller\AppController.java,"package com.web.carhire.controller;

import java.util.Arrays;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.SessionAttribute;
import org.springframework.web.bind.annotation.SessionAttributes;
import org.springframework.web.bind.support.SessionStatus;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.web.carhire.model.States;
import com.web.carhire.model.Users;
import com.web.carhire.service.UserService;
import com.web.carhire.util.DataValidation;
import com.web.carhire.util.WebServiceUtils;

@Controller
@SessionAttributes({""logedinUser""})
public class AppController {
	
	@Value(""${spring.queries.users-query}"")
	private String msg;	
	
	@Autowired
	private WebServiceUtils webServiceUtils;
	
	@Autowired
	private DataValidation dataValidator;
	
	@Autowired
	private UserService userService;
	
	@PostMapping(""sendmail"")
	String sendmail(@RequestParam String email, @RequestParam String msg,
			@RequestParam String subject, Model model) {
	 model.addAttribute(""msg"", webServiceUtils.sendMail(email, msg, subject));
		
	 return ""contact"";		
	}
	
	@GetMapping({""/"",""/index""})
	String index(Model model) {
//	 model.addAttribute(""list"", userService.findAll());	
	model.addAttribute(""msg"", ""Welcome to Car hire.com"");	
     return ""index"";	
	}	
	
	@GetMapping(""about"")
	String about(Model model) {
		model.addAttribute(""msg"", ""about us "");
     return ""about"";		
	}
	
	@GetMapping(""contact"")
	String contact(Model model) {
		model.addAttribute(""msg"", ""contact us "");
     return ""contact"";		
	}
	
	@GetMapping(""login"")
	String login(Model model) {
	  model.addAttribute(""msg"", ""Login"");
	  return ""login"";		
	}
	
	@GetMapping(""members"")
	String members(Model model) {
	  model.addAttribute(""msg"", ""Members"");
	  return ""members"";		
	}
	
	@GetMapping(""edituser-{id}"")
	String edit(@PathVariable long id, Model model) {	  
		model.addAttribute(""msg"", ""Update"");
	    model.addAttribute(""user"", userService.findById(id));
		return ""updateuser"";	  		
	}
	
	@PostMapping(""updateuser"")
	String update(@ModelAttribute Users user, RedirectAttributes redirect) {
		try {			
			Users usr=userService.findById(user.getId());
			MultipartFile multipartFile = (MultipartFile) user.getFile();
			if(multipartFile.getSize() != 0) {
				webServiceUtils.saveImage(user.getFile(), user.getId());	
				usr.setImage(multipartFile.getOriginalFilename());				
			}
			userService.update(usr);
			redirect.addFlashAttribute(""success"", ""Update success for ""+ user.getCompanyName());
		} catch (Exception e) {
			e.printStackTrace();
			redirect.addFlashAttribute(""error"", ""Unexpected Error""+e.getLocalizedMessage());
			return ""redirect:/error"";
		}
		return ""redirect:/index"";
	}
	
	@GetMapping(""deleteuser-{id}"")
	String delet(@PathVariable long id, RedirectAttributes redirect) {
		try {
			//Users user=usersRepository.findById(id).get();
			userService.delete(id);
			redirect.addFlashAttribute(""success"", ""Delete Success"");
		} catch (Exception e) {
			e.printStackTrace();
			redirect.addFlashAttribute(""error"", ""Delete Fail"");			
		}
	  return ""redirect:/index"";		
	}
		
	@PostMapping(""login"")
	String login(@ModelAttribute Users user, Model model) {
		Users usr=userService.findByEmail(user.getEmail());
		if(usr!=null && user.getPassword().equals(usr.getPassword())) {
			model.addAttribute(""success"", ""Login Success"");
			model.addAttribute(""logedinUser"", usr);
		  return ""redirect:/profile""; 
		}else {
		 model.addAttribute(""error"", ""Invalid credentials "");
		}
	 return ""login"";		
	}
	
	
	  @GetMapping(""/user-{id}"") 
	  public String profile(@PathVariable long id,
	  Model model) {
		  model.addAttribute(""member"", userService.findById(id));
		  webServiceUtils.getFiles(model, id);
	  return ""member""; 
	  }
	 
	 
	@GetMapping(""/profile"")
	public String profile(@SessionAttribute(""logedinUser"") Users user,Model model) {
		
		webServiceUtils.getFiles(model, user.getId());
		
		return ""profile"";
	}
	
	
	@GetMapping(""/logout"")
	public String logout(Model model, WebRequest request, 
			SessionStatus status, RedirectAttributes redirect){	
		status.setComplete();
		request.removeAttribute(""logedinUser"", WebRequest.SCOPE_SESSION);
		redirect.addFlashAttribute(""success"", ""You have been signed out"");
		return ""redirect:/login"";
	}
		
	@GetMapping(""register"")
	String register(Model model) {
	 model.addAttribute(""msg"", ""Register"");
	 model.addAttribute(""users"", new Users());
	return ""register"";		
	}
	
	
	@PostMapping(""register"")
	String signup(@ModelAttribute Users user, BindingResult result,RedirectAttributes model) {
		
		try {			
			  dataValidator.validate(user, result);
			  if (result.hasErrors()) {
			  model.addAttribute(""msg"", ""Register"");
			  return ""register""; 
			  }
			userService.save(user);
			String msg=""Thanks you for registering "";
			String sent= webServiceUtils.sendMail(user.getEmail(), msg, ""Registration"");
			model.addFlashAttribute(""success"", ""Registration success thank you ""+sent);
				
		} catch (Exception e) {
			e.printStackTrace();
		}		
		return ""redirect:/login"";				
	}
	
	@PostMapping(""search"")
	String search(@RequestParam String companyNameme, Model model){
	 try {
		model.addAttribute(""list"", userService.findByLastName(companyNameme));
	} catch (Exception e) {
		e.printStackTrace();
		model.addAttribute(""error"", ""Unexpected error occured"");
	}
	return ""index"";		
	}
	
	@PostMapping(""looking"")
	String lookup(@RequestParam String email,@RequestParam String companyName, Model model){
	 try {
		model.addAttribute(""list"", userService.findByNameOrEmail(companyName, email));
	} catch (Exception e) {
		e.printStackTrace();
		model.addAttribute(""error"", ""Unexpected error occured"");
	}
	    return ""index"";		
	}
	
	
	@PostMapping(""editrole"")
	String addrole(@RequestParam long id, @RequestParam String role, 
			RedirectAttributes red) {
	 try {			
		 userService.setRole(id, role);		 
		 red.addFlashAttribute(""success"","" has been asigned ""+role+"" role"");
	} catch (Exception e) {
		e.printStackTrace();
	}
	 return ""redirect:/index"";		
	}
	
	@ModelAttribute(""user"")
	Users user() {
	 return new Users();
	}
	
	//for populating states 
    @ModelAttribute(""states"")
    public List<States> populateStates(){
        return Arrays.asList(States.values());
    }
	
      @ResponseBody
	  @GetMapping(""/hello"")
	    public String hellow() {		
		  return ""Hellow from Contoller""; 		  
	  }
	
	
}
"
-2961264689473449951,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\controller\RestApiController.java,"package com.web.carhire.controller;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.List;
import java.util.Optional;

import javax.validation.Valid;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.web.carhire.model.Users;
import com.web.carhire.repository.UsersRepository;

@RestController
@RequestMapping(""/api"")
public class RestApiController {
	
	private final Logger log = LoggerFactory.getLogger(RestApiController.class);
	
	@Autowired
	public UsersRepository userRepository;

	  @GetMapping(""/users"")
	  public List<Users> getAllUsers() {
		log.info(""Request to get all Users: {}"", userRepository.findAll());
	    return userRepository.findAll();
	  }
	  
	    @GetMapping(""/user/{id}"")
	    ResponseEntity<?> getUser(@PathVariable Long id) {
	        Optional<Users> user = userRepository.findById(id);
	        return user.map(response -> ResponseEntity.ok().body(response))
	                .orElse(new ResponseEntity<>(HttpStatus.NOT_FOUND));
	    }

	    @PostMapping(""/user"")
	    ResponseEntity<Users> createUser(@Valid @RequestBody Users user) throws URISyntaxException {
	        log.info(""Request to create User: {}"", user);
	        Users result = userRepository.save(user);
	        return ResponseEntity.created(new URI(""/api/user/"" + result.getId()))
	                .body(result);
	    }

	    @PutMapping(""/user/{id}"")
	    ResponseEntity<Users> updateUser(@Valid @RequestBody Users user) {
	        log.info(""Request to update user: {}"", user);
	        Users result = userRepository.save(user);
	        return ResponseEntity.ok().body(result);
	    }

	    @DeleteMapping(""/user/{id}"")
	    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
	        log.info(""Request to delete user: {}"", id);
	        userRepository.deleteById(id);
	        return ResponseEntity.ok().build();
	    }
}
"
-5617037087514382858,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\controller\UploadController.java,"package com.web.carhire.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.web.carhire.model.Users;
import com.web.carhire.repository.UsersRepository;
import com.web.carhire.util.WebServiceUtils;

@Controller
public class UploadController {

    @Autowired
    private UsersRepository usersRepository;

    @Autowired
    private WebServiceUtils webServiceUtils;

    @PostMapping(""uploadMultipleFiles"")
    public String uploadMultipleFiles(Model model, @RequestParam long id, @RequestParam(""uploadingFiles"") MultipartFile[] files) {
        try {

            if (webServiceUtils.multiplesave(files, id) == ""Success"") {
                model.addAttribute(""msg"", files.length + "" Files uploaded<br>"");
            } else {
                model.addAttribute(""msg"", "" Please select files<br>"");
            }
            webServiceUtils.getFiles(model, id);

        } catch (Exception e) {
            model.addAttribute(""error"", "" unxpected error<br>"");

            e.printStackTrace();
        }
        return ""profile"";
    }

    @GetMapping(""setasprofile"")
    String setprofile(RedirectAttributes red,
            @RequestParam String email, @RequestParam String image, Model model) {

        try {
            Users user = usersRepository.findByEmail(email);
            user.setImage(image);
            usersRepository.save(user);
            red.addFlashAttribute(""success"", ""Image set to "" + image);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return ""redirect:/index"";
    }

    @GetMapping(""deleteimage"")
    String removeImage(RedirectAttributes red, @RequestParam long id,
            @RequestParam String image, Model model) {

        try {
            webServiceUtils.removefiles(id, image);
            red.addFlashAttribute(""success"", ""Image deleted"");

        } catch (Exception e) {
            e.printStackTrace();
        }

        return ""redirect:/profile"";
    }

}
"
6996718589695726488,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\model\States.java,"package com.web.carhire.model;

public enum States {
	AL(""Alabama""),
    MT(""Montana""),
    AK(""Alaska""),
    NE(""Nebraska""),
    AZ(""Arizona""),
    NV(""Nevada""),
    AR(""Arkansas""),
    NH(""New Hampshire""),
    CA(""California""),
    NJ(""New Jersey""),
    CO(""Colorado""),
    NM(""New Mexico""),
    CT(""Connecticut""),
    NY(""New York""),
    DE(""Delaware""),
    NC(""North Carolina""),
    FL(""Florida""),
    ND(""North Dakota""),
    GA(""Georgia""),
    OH(""Ohio""),
    HI(""Hawaii""),
    OK(""Oklahoma""),
    ID(""Idaho""),
    OR(""Oregon""),
    IL(""Illinois""),
    PA(""Pennsylvania""),
    IN(""Indiana""),
    RI(""Rhode Island""),
    IA(""Iowa""),
    SC(""South Carolina""),
    KS(""Kansas""),
    SD(""South Dakota""),
    KY(""Kentucky""),
    TN(""Tennessee""),
    LA(""Louisiana""),
    TX(""Texas""),
    ME(""Maine""),
    UT(""Utah""),
    MD(""Maryland""),
    VT(""Vermont""),
    MA(""Massachusetts""),
    VA(""Virginia""),
    MI(""Michigan""),
    WA(""Washington""),
    MN(""Minnesota""),
    WV(""West Virginia""),
    MS(""Mississippi""),
    WI(""Wisconsin""),
    MO(""Missouri""),
    WY(""Wyoming"");
	

     private String id;

     private States(String id){
         this.id = id;
     }

     public String getId()
     {
         return id;
     }
     
     public enum Days {
    	 SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY;
 	 }
     
     
}
"
4469127749199817766,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\model\Users.java,"package com.web.carhire.model;

import java.util.Date;

import javax.persistence.*;

import org.springframework.web.multipart.MultipartFile;

@Entity
@Table(name=""users"")
public class Users{
	
	@Id
	@GeneratedValue(strategy=GenerationType.AUTO)
	@Column(name=""id"")
	private long id;
	private String email;
	@Transient
	private String email2;
	@Transient
	MultipartFile file;
	private String image;
        @Transient
	private String password;
	private Date createdDate;
	/* private String lastName; */
	private String companyName;
	private String role;	
	private String zip;
	private String address;
	private String city;
	private String state;
	
	public long getId() {
		return id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getEmail2() {
		return email2;
	}
	public void setEmail2(String email2) {
		this.email2 = email2;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Date getCreatedDate() {
		return createdDate;
	}
	public void setCreatedDate(Date createdDate) {
		this.createdDate = createdDate;
	}	
	public String getCompanyName() {
		return companyName;
	}
	public void setCompanyName(String companyName) {
		this.companyName = companyName;
	}
	
	/*
	 * public String getLastName() { return lastName; } public void setLname(String
	 * lastName) { this.lastName = lastName; }
	 */

	/*
	 * public String getFname() { return fname; } public void setFname(String fname)
	 * { this.fname = fname;
	 */
	//}
		
	public MultipartFile getFile() {
		return file;
	}
	public void setFile(MultipartFile file) {
		this.file = file;
	}
	
	public String getRole() {
		return role;
	}
	public void setRole(String role) {
		this.role = role;
	}	
	public String getImage() {
		return image;
	}
	public void setImage(String image) {
		this.image = image;
	}	
	public String getZip() {
		return zip;
	}
	public void setZip(String zip) {
		this.zip = zip;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public String getState() {
		return state;
	}
	public void setState(String state) {
		this.state = state;
	}
	
	public String getCity() {
		return city;
	}
	public void setCity(String city) {
		this.city = city;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (int) (id ^ (id >>> 32));
		return result;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Users other = (Users) obj;
		if (id != other.id)
			return false;
		return true;
	}
	@Override
	public String toString() {
		return ""Users [id="" + id + "", email="" + email + "", email2="" + email2 + "", file="" + file + "", image="" + image
				+ "", password="" + password + "", createdDate="" + createdDate
				/* + "", lastName="" + lastName */  + "", companyName=""
				+ companyName + "", role="" + role + "", zip="" + zip + "", address="" + address + "", city="" + city
				+ "", state="" + state + ""]"";
	}
	
	
	

}
"
5477214709545861919,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\repository\UsersRepository.java,"package com.web.carhire.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

import com.web.carhire.model.Users;

public interface UsersRepository extends JpaRepository<Users, Long> {
	
	Users findByEmail(String email);
	@Query(""FROM Users WHERE lname = ?1 OR fname = ?1"")
	List<Users> findByName(String companyName);
	
	@Query(""FROM Users WHERE lname = ?1 AND email = ?2"")
	List<Users> findByNameOrEmail(String name, String email);
	
}
"
-2333185961593098738,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\service\UserService.java,"package com.web.carhire.service;

import java.util.List;

import com.web.carhire.model.Users;

public interface UserService {
  
	Users findByEmail(String email);
	Users findById(long id);
	List<Users> findAll();
	List<Users> findByLastName(String name);
	List<Users> findByNameOrEmail(String lname, String email);
	void update(Users user);
	void save(Users user);
	void delete(long id);
	void setRole(long id, String role);
	List<Users> findByCompanyName(String companyName);
	
	
	
	
}
"
7507606392887638230,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\service\UserServiceImpl.java,"package com.web.carhire.service;

import java.util.Date;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.web.carhire.model.Users;
import com.web.carhire.repository.UsersRepository;

@Service
@Transactional
public class UserServiceImpl implements UserService {

	
	private UsersRepository usersRepository;
	
	@Autowired
	public UserServiceImpl(UsersRepository usersRepository) {
		super();
		this.usersRepository = usersRepository;
	}

	@Override
	public Users findByEmail(String email) {
	 return usersRepository.findByEmail(email);
	}

	@Override
	public Users findById(long id) {
		return usersRepository.findById(id).get();
	}

	@Override
	public List<Users> findAll() {
		return usersRepository.findAll();
	}

	@Override
	public void update(Users user) {
	  Users usr=findById(user.getId());
	  if(usr!=null) {
		 usr.setCompanyName(user.getCompanyName());
			/* usr.setCompanyName(user.getcompanyName()); */
		 usr.setAddress(user.getAddress());
		 usr.setCity(user.getCity());
		 usr.setState(user.getState());
		 usr.setZip(user.getZip());
		 usr.setCity(user.getCity());
	  }
	}

	@Override
	public void save(Users user) {
		user.setCreatedDate(new Date());
		user.setRole(""USER"");
		usersRepository.save(user);
	}

	@Override
	public void delete(long id) {
		usersRepository.delete(findById(id));
	}

	@Override
	public void setRole(long id, String role) {
		findById(id).setRole(role);		
	}

	@Override
	public List<Users> findByNameOrEmail(String lname, String email) {
		return usersRepository.findByNameOrEmail(lname, email);
	}

	@Override
	public List<Users> findByCompanyName(String companyName) {
		return usersRepository.findByName(companyName);
	}

	@Override
	public List<Users> findByLastName(String name) {
		// TODO Auto-generated method stub
		return null;
	}

}
"
1399096068463030589,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\util\DataValidation.java,"package com.web.carhire.util;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.*;

import com.web.carhire.model.Users;
import com.web.carhire.repository.UsersRepository;

@Component
public class DataValidation implements Validator {
	
	private UsersRepository userRepository;
	
	String emailRegex = ""^[\\w-_\\.+]*[\\w-_\\.]\\@([\\w]+\\.)+[\\w]+[\\w]$"";
			
	@Autowired
	public DataValidation(UsersRepository userRepository) {
		this.userRepository = userRepository;
	}
	
	public boolean supports(Class<?> clazz) {
		return Users.class.isAssignableFrom(clazz);
	}

	public void validate(Object o, Errors errors) {
		Users user = (Users) o;
		
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, ""companyName"", ""NotEmpty"");
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, ""companyName"", ""NotEmpty"");
		
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, ""email"", ""NotEmpty"");		
		if (userRepository.findByEmail(user.getEmail()) !=null) {
	    	errors.rejectValue(""email"", ""size.user.unique"");
	    }
		
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, ""password"", ""NotEmpty"");
        if (user.getPassword().length() <=0  ||  user.getPassword().length() < 4) {
	    	errors.rejectValue(""password"", ""size.user.password"");
	    }
        
        if (!user.getEmail().equalsIgnoreCase(user.getEmail2())) {
	    	errors.rejectValue(""email2"", ""size.user.match"");
	    }
        
        if (!user.getEmail().matches(emailRegex)) {
        	errors.rejectValue(""email"", ""size.user.email"");
	    }
        
		
	}
}"
5168642476483845968,F://JavaWorkspace//capstone\src\main\java\com\web\carhire\util\WebServiceUtils.java,"package com.web.carhire.util;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Component;
import org.springframework.ui.Model;
import org.springframework.web.multipart.MultipartFile;

@Component
public class WebServiceUtils{
    
    private JavaMailSender sender;
    
    //private static final String UPLOADED_FOLDER = ""/Tutorials/images/users/carhire/"";
    
    private static final String UPLOADED_FOLDER = ""C:\\Tutorials\\images\\users\\carhire\\"";
    
    @Autowired    
    public WebServiceUtils(JavaMailSender sender) {
		super();
		this.sender = sender;
	}

	public String sendMail(String to, String msg, String subject) {
        MimeMessage message = sender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message);
        try {
            helper.setTo(to);
            helper.setText(msg);
            helper.setSubject(subject);
        } catch (MessagingException e) {
            e.printStackTrace();
            return ""Error while sending mail .."";
        }
        try {
			sender.send(message);
		} catch (MailException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return ""E-Mail Sent Successfully!"";
     }
    
       //save a single file to locale file system
	   public void saveImage(MultipartFile file, long id) throws IllegalStateException, IOException {
		    try {
		    	// save dir
		 	    String destDir = UPLOADED_FOLDER+ File.separator + id;                        
		 	    //innitalize file
				File dir = new File(destDir);
				//if folder does not exist create it
				if(!dir.exists()){                                    	 
					new File(destDir).mkdirs();                                        
				 }
				//get file from form
				MultipartFile multipartFile = (MultipartFile) file; 
				//set folder to save file system 
				File doc = new File(destDir + File.separator +  multipartFile.getOriginalFilename());
				 //save to file system
				multipartFile.transferTo(doc);
			} catch (Exception e) {
				e.printStackTrace();
			}
			 
	   }
	   
	   //save multiple files to locale file system
	   public String multiplesave(MultipartFile[] files, long id) throws IllegalStateException, IOException {
		    	  
		     File dir = new File(UPLOADED_FOLDER + File.separator + id );			  
			  for (int i = 0; i < files.length; i++){ 
			  MultipartFile file = files[i]; 
			  try { 		      
			  if (!dir.exists()) dir.mkdirs();			  
			  String destpath=UPLOADED_FOLDER + File.separator + id+ File.separator+ file.getOriginalFilename(); 
			  File destfile= new File(destpath);			  
			  file.transferTo(destfile);
		     } catch (Exception e) {
			  e.printStackTrace();
			  return ""Upload fail"";
		   } 
		  }
		return ""Success"";
			 
	   }
	   
		   
	   public void removefiles(long id, String image) {
		try {
			File file = new File(UPLOADED_FOLDER + File.separator 
					+ id+ File.separator +image+"""");    		
	 	    if(file.delete()){
			System.out.println(file.getName() + "" is deleted!"");				
			}else{
				System.out.println(""Delete operation is failed."");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	   }
	   
	   public void getFiles(Model model, long id) {
	    	List<String> results = new ArrayList<String>();
			try {
				File dir = new File(UPLOADED_FOLDER + File.separator + id );			  
				File[] files = new File(UPLOADED_FOLDER + File.separator + id).listFiles();
				if (!dir.exists()) dir.mkdirs();
				for (File file : files) {
				    if (file.isFile()) {
				        results.add(file.getName());
				        model.addAttribute(""filesname"", results);
				     }				   
				}
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	    }
		
	   
    
    
}"
-3822876851211329853,F://JavaWorkspace//capstone\src\test\java\com\web\carhire\CarhireApplicationTests.java,"package com.web.carhire;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.web.client.RestClientException;

import com.web.carhire.model.Users;
import com.web.carhire.service.UserService;

//@RunWith(SpringRunner.class)
//@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class CarhireApplicationTests {

private final Logger log = LoggerFactory.getLogger(CarhireApplicationTests.class);
	/*	
	@Autowired
	private UserService userService;
	
	@Value(""${server.port}"")
	private long iport;
	
	@LocalServerPort
	private long port;
	
	@Autowired
	private TestRestTemplate restTemplate;
	
	@Test
	public void contextLoads() {
		log.info(""############ users ""+userService.findAll());
		assertNotNull(userService.findAll());
	}
	
	@Test
	public void getUsers() {
		 String url=""http://localhost:8500/carsale/api/users"";
		 @SuppressWarnings({ ""rawtypes"", ""unchecked"" })
		 List<ArrayList> getList= restTemplate.getForObject(url, List.class);		 
		 assertNotNull(getList);
		 log.info(""Request to get all Users: {}"", getList);
	}
	
	@Test
	public void hellow() throws RestClientException, MalformedURLException {
		 ResponseEntity<String> response=restTemplate.getForEntity
		 (new URL(""http://localhost:8500/carsale/hello"").toString(), String.class);
		 assertEquals(""Hellow from Contoller"", response.getBody());
		 log.info(""Request to hello {}"", response.getBody());
		 
	}
	
	@Test
	public void getUser() throws RestClientException, MalformedURLException {
		 String url=""http://localhost:""+port+""/carsale/api/user/4"";
		 ResponseEntity<Users> response=restTemplate.getForEntity
		 (url, Users.class);
		 assertEquals(""ken.juma@yahoo.com"", response.getBody().getEmail());
		 log.info(""Request to get all Users: {}"", response);
		 
	}
		
	@Test
	public void getEmail() {
		  Users user=userService.findByEmail(""ken.juma@yahoo.com""); 
		  log.info(""############ user entity ""+user.toString());		  
		  assertEquals(""ken.juma@yahoo.com"", user.getEmail()); 
		  assertEquals(""Mwalimu"", user.getCompanyName()); 
		  assertEquals(""Juma"", user.getCompanyName());
		  assertNotNull(user.getCompanyName());
		 
	}
	
	@Test
	public void calculator() {
		  assertEquals(16, mutliply(4,4));
		  assertEquals(20, sum(10,10));
		  
		  
	}
	
	int mutliply(int a, int b){
		return b*a;		
	}
	
	int sum(int a, int b){
		return b+a;		
	}
	*/
}
"
-7457816109008129930,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\CustomerJpaController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.controllers;

import java.util.List;
import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.EntityNotFoundException;
import javax.transaction.UserTransaction;
import jpa.controllers.exceptions.IllegalOrphanException;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.PreexistingEntityException;
import jpa.controllers.exceptions.RollbackFailureException;
import jpa.entities.Customer;
import jpa.entities.DiscountCode;
import jpa.entities.PurchaseOrder;
import java.util.ArrayList;
import java.util.Collection;

/**
 *
 * @author mbohm
 */
public class CustomerJpaController {
    @Resource
    private UserTransaction utx = null;
    @PersistenceUnit(unitName = ""JsfJpaCrudPU"")
    private EntityManagerFactory emf = null;

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void create(Customer customer) throws PreexistingEntityException, RollbackFailureException, Exception {
        if (customer.getPurchaseOrderCollection() == null) {
            customer.setPurchaseOrderCollection(new ArrayList<PurchaseOrder>());
        }
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            DiscountCode discountCode = customer.getDiscountCode();
            if (discountCode != null) {
                discountCode = em.getReference(discountCode.getClass(), discountCode.getDiscountCode());
                customer.setDiscountCode(discountCode);
            }
            List<PurchaseOrder> attachedPurchaseOrderCollection = new ArrayList<PurchaseOrder>();
            for (PurchaseOrder purchaseOrderCollectionPurchaseOrderToAttach : customer.getPurchaseOrderCollection()) {
                purchaseOrderCollectionPurchaseOrderToAttach = em.getReference(purchaseOrderCollectionPurchaseOrderToAttach.getClass(), purchaseOrderCollectionPurchaseOrderToAttach.getOrderNum());
                attachedPurchaseOrderCollection.add(purchaseOrderCollectionPurchaseOrderToAttach);
            }
            customer.setPurchaseOrderCollection(attachedPurchaseOrderCollection);
            em.persist(customer);
            if (discountCode != null) {
                discountCode.getCustomerCollection().add(customer);
                discountCode = em.merge(discountCode);
            }
            for (PurchaseOrder purchaseOrderCollectionPurchaseOrder : customer.getPurchaseOrderCollection()) {
                Customer oldCustomerIdOfPurchaseOrderCollectionPurchaseOrder = purchaseOrderCollectionPurchaseOrder.getCustomerId();
                purchaseOrderCollectionPurchaseOrder.setCustomerId(customer);
                purchaseOrderCollectionPurchaseOrder = em.merge(purchaseOrderCollectionPurchaseOrder);
                if (oldCustomerIdOfPurchaseOrderCollectionPurchaseOrder != null) {
                    oldCustomerIdOfPurchaseOrderCollectionPurchaseOrder.getPurchaseOrderCollection().remove(purchaseOrderCollectionPurchaseOrder);
                    oldCustomerIdOfPurchaseOrderCollectionPurchaseOrder = em.merge(oldCustomerIdOfPurchaseOrderCollectionPurchaseOrder);
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            if (findCustomer(customer.getCustomerId()) != null) {
                throw new PreexistingEntityException(""Customer "" + customer + "" already exists."", ex);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void edit(Customer customer) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Customer persistentCustomer = em.find(Customer.class, customer.getCustomerId());
            DiscountCode discountCodeOld = persistentCustomer.getDiscountCode();
            DiscountCode discountCodeNew = customer.getDiscountCode();
            Collection<PurchaseOrder> purchaseOrderCollectionOld = persistentCustomer.getPurchaseOrderCollection();
            Collection<PurchaseOrder> purchaseOrderCollectionNew = customer.getPurchaseOrderCollection();
            List<String> illegalOrphanMessages = null;
            for (PurchaseOrder purchaseOrderCollectionOldPurchaseOrder : purchaseOrderCollectionOld) {
                if (!purchaseOrderCollectionNew.contains(purchaseOrderCollectionOldPurchaseOrder)) {
                    if (illegalOrphanMessages == null) {
                        illegalOrphanMessages = new ArrayList<String>();
                    }
                    illegalOrphanMessages.add(""You must retain PurchaseOrder "" + purchaseOrderCollectionOldPurchaseOrder + "" since its customerId field is not nullable."");
                }
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            if (discountCodeNew != null) {
                discountCodeNew = em.getReference(discountCodeNew.getClass(), discountCodeNew.getDiscountCode());
                customer.setDiscountCode(discountCodeNew);
            }
            List<PurchaseOrder> attachedPurchaseOrderCollectionNew = new ArrayList<PurchaseOrder>();
            for (PurchaseOrder purchaseOrderCollectionNewPurchaseOrderToAttach : purchaseOrderCollectionNew) {
                purchaseOrderCollectionNewPurchaseOrderToAttach = em.getReference(purchaseOrderCollectionNewPurchaseOrderToAttach.getClass(), purchaseOrderCollectionNewPurchaseOrderToAttach.getOrderNum());
                attachedPurchaseOrderCollectionNew.add(purchaseOrderCollectionNewPurchaseOrderToAttach);
            }
            purchaseOrderCollectionNew = attachedPurchaseOrderCollectionNew;
            customer.setPurchaseOrderCollection(purchaseOrderCollectionNew);
            customer = em.merge(customer);
            if (discountCodeOld != null && !discountCodeOld.equals(discountCodeNew)) {
                discountCodeOld.getCustomerCollection().remove(customer);
                discountCodeOld = em.merge(discountCodeOld);
            }
            if (discountCodeNew != null && !discountCodeNew.equals(discountCodeOld)) {
                discountCodeNew.getCustomerCollection().add(customer);
                discountCodeNew = em.merge(discountCodeNew);
            }
            for (PurchaseOrder purchaseOrderCollectionNewPurchaseOrder : purchaseOrderCollectionNew) {
                if (!purchaseOrderCollectionOld.contains(purchaseOrderCollectionNewPurchaseOrder)) {
                    Customer oldCustomerIdOfPurchaseOrderCollectionNewPurchaseOrder = purchaseOrderCollectionNewPurchaseOrder.getCustomerId();
                    purchaseOrderCollectionNewPurchaseOrder.setCustomerId(customer);
                    purchaseOrderCollectionNewPurchaseOrder = em.merge(purchaseOrderCollectionNewPurchaseOrder);
                    if (oldCustomerIdOfPurchaseOrderCollectionNewPurchaseOrder != null && !oldCustomerIdOfPurchaseOrderCollectionNewPurchaseOrder.equals(customer)) {
                        oldCustomerIdOfPurchaseOrderCollectionNewPurchaseOrder.getPurchaseOrderCollection().remove(purchaseOrderCollectionNewPurchaseOrder);
                        oldCustomerIdOfPurchaseOrderCollectionNewPurchaseOrder = em.merge(oldCustomerIdOfPurchaseOrderCollectionNewPurchaseOrder);
                    }
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            String msg = ex.getLocalizedMessage();
            if (msg == null || msg.length() == 0) {
                Integer id = customer.getCustomerId();
                if (findCustomer(id) == null) {
                    throw new NonexistentEntityException(""The customer with id "" + id + "" no longer exists."");
                }
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void destroy(Integer id) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Customer customer;
            try {
                customer = em.getReference(Customer.class, id);
                customer.getCustomerId();
            } catch (EntityNotFoundException enfe) {
                throw new NonexistentEntityException(""The customer with id "" + id + "" no longer exists."", enfe);
            }
            List<String> illegalOrphanMessages = null;
            Collection<PurchaseOrder> purchaseOrderCollectionOrphanCheck = customer.getPurchaseOrderCollection();
            for (PurchaseOrder purchaseOrderCollectionOrphanCheckPurchaseOrder : purchaseOrderCollectionOrphanCheck) {
                if (illegalOrphanMessages == null) {
                    illegalOrphanMessages = new ArrayList<String>();
                }
                illegalOrphanMessages.add(""This Customer ("" + customer + "") cannot be destroyed since the PurchaseOrder "" + purchaseOrderCollectionOrphanCheckPurchaseOrder + "" in its purchaseOrderCollection field has a non-nullable customerId field."");
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            DiscountCode discountCode = customer.getDiscountCode();
            if (discountCode != null) {
                discountCode.getCustomerCollection().remove(customer);
                discountCode = em.merge(discountCode);
            }
            em.remove(customer);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public List<Customer> findCustomerEntities() {
        return findCustomerEntities(true, -1, -1);
    }

    public List<Customer> findCustomerEntities(int maxResults, int firstResult) {
        return findCustomerEntities(false, maxResults, firstResult);
    }

    private List<Customer> findCustomerEntities(boolean all, int maxResults, int firstResult) {
        EntityManager em = getEntityManager();
        try {
            Query q = em.createQuery(""select object(o) from Customer as o"");
            if (!all) {
                q.setMaxResults(maxResults);
                q.setFirstResult(firstResult);
            }
            return q.getResultList();
        } finally {
            em.close();
        }
    }

    public Customer findCustomer(Integer id) {
        EntityManager em = getEntityManager();
        try {
            return em.find(Customer.class, id);
        } finally {
            em.close();
        }
    }

    public int getCustomerCount() {
        EntityManager em = getEntityManager();
        try {
            return ((Long) em.createQuery(""select count(o) from Customer as o"").getSingleResult()).intValue();
        } finally {
            em.close();
        }
    }

}
"
-3849021144370273564,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\DiscountCodeJpaController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.controllers;

import java.util.List;
import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.EntityNotFoundException;
import javax.transaction.UserTransaction;
import jpa.controllers.exceptions.IllegalOrphanException;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.PreexistingEntityException;
import jpa.controllers.exceptions.RollbackFailureException;
import jpa.entities.Customer;
import java.util.ArrayList;
import java.util.Collection;
import jpa.entities.DiscountCode;

/**
 *
 * @author mbohm
 */
public class DiscountCodeJpaController {
    @Resource
    private UserTransaction utx = null;
    @PersistenceUnit(unitName = ""JsfJpaCrudPU"")
    private EntityManagerFactory emf = null;

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void create(DiscountCode discountCode) throws PreexistingEntityException, RollbackFailureException, Exception {
        if (discountCode.getCustomerCollection() == null) {
            discountCode.setCustomerCollection(new ArrayList<Customer>());
        }
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            List<Customer> attachedCustomerCollection = new ArrayList<Customer>();
            for (Customer customerCollectionCustomerToAttach : discountCode.getCustomerCollection()) {
                customerCollectionCustomerToAttach = em.getReference(customerCollectionCustomerToAttach.getClass(), customerCollectionCustomerToAttach.getCustomerId());
                attachedCustomerCollection.add(customerCollectionCustomerToAttach);
            }
            discountCode.setCustomerCollection(attachedCustomerCollection);
            em.persist(discountCode);
            for (Customer customerCollectionCustomer : discountCode.getCustomerCollection()) {
                DiscountCode oldDiscountCodeOfCustomerCollectionCustomer = customerCollectionCustomer.getDiscountCode();
                customerCollectionCustomer.setDiscountCode(discountCode);
                customerCollectionCustomer = em.merge(customerCollectionCustomer);
                if (oldDiscountCodeOfCustomerCollectionCustomer != null) {
                    oldDiscountCodeOfCustomerCollectionCustomer.getCustomerCollection().remove(customerCollectionCustomer);
                    oldDiscountCodeOfCustomerCollectionCustomer = em.merge(oldDiscountCodeOfCustomerCollectionCustomer);
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            if (findDiscountCode(discountCode.getDiscountCode()) != null) {
                throw new PreexistingEntityException(""DiscountCode "" + discountCode + "" already exists."", ex);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void edit(DiscountCode discountCode) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            DiscountCode persistentDiscountCode = em.find(DiscountCode.class, discountCode.getDiscountCode());
            Collection<Customer> customerCollectionOld = persistentDiscountCode.getCustomerCollection();
            Collection<Customer> customerCollectionNew = discountCode.getCustomerCollection();
            List<String> illegalOrphanMessages = null;
            for (Customer customerCollectionOldCustomer : customerCollectionOld) {
                if (!customerCollectionNew.contains(customerCollectionOldCustomer)) {
                    if (illegalOrphanMessages == null) {
                        illegalOrphanMessages = new ArrayList<String>();
                    }
                    illegalOrphanMessages.add(""You must retain Customer "" + customerCollectionOldCustomer + "" since its discountCode field is not nullable."");
                }
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            List<Customer> attachedCustomerCollectionNew = new ArrayList<Customer>();
            for (Customer customerCollectionNewCustomerToAttach : customerCollectionNew) {
                customerCollectionNewCustomerToAttach = em.getReference(customerCollectionNewCustomerToAttach.getClass(), customerCollectionNewCustomerToAttach.getCustomerId());
                attachedCustomerCollectionNew.add(customerCollectionNewCustomerToAttach);
            }
            customerCollectionNew = attachedCustomerCollectionNew;
            discountCode.setCustomerCollection(customerCollectionNew);
            discountCode = em.merge(discountCode);
            for (Customer customerCollectionNewCustomer : customerCollectionNew) {
                if (!customerCollectionOld.contains(customerCollectionNewCustomer)) {
                    DiscountCode oldDiscountCodeOfCustomerCollectionNewCustomer = customerCollectionNewCustomer.getDiscountCode();
                    customerCollectionNewCustomer.setDiscountCode(discountCode);
                    customerCollectionNewCustomer = em.merge(customerCollectionNewCustomer);
                    if (oldDiscountCodeOfCustomerCollectionNewCustomer != null && !oldDiscountCodeOfCustomerCollectionNewCustomer.equals(discountCode)) {
                        oldDiscountCodeOfCustomerCollectionNewCustomer.getCustomerCollection().remove(customerCollectionNewCustomer);
                        oldDiscountCodeOfCustomerCollectionNewCustomer = em.merge(oldDiscountCodeOfCustomerCollectionNewCustomer);
                    }
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            String msg = ex.getLocalizedMessage();
            if (msg == null || msg.length() == 0) {
                Character id = discountCode.getDiscountCode();
                if (findDiscountCode(id) == null) {
                    throw new NonexistentEntityException(""The discountCode with id "" + id + "" no longer exists."");
                }
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void destroy(Character id) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            DiscountCode discountCode;
            try {
                discountCode = em.getReference(DiscountCode.class, id);
                discountCode.getDiscountCode();
            } catch (EntityNotFoundException enfe) {
                throw new NonexistentEntityException(""The discountCode with id "" + id + "" no longer exists."", enfe);
            }
            List<String> illegalOrphanMessages = null;
            Collection<Customer> customerCollectionOrphanCheck = discountCode.getCustomerCollection();
            for (Customer customerCollectionOrphanCheckCustomer : customerCollectionOrphanCheck) {
                if (illegalOrphanMessages == null) {
                    illegalOrphanMessages = new ArrayList<String>();
                }
                illegalOrphanMessages.add(""This DiscountCode ("" + discountCode + "") cannot be destroyed since the Customer "" + customerCollectionOrphanCheckCustomer + "" in its customerCollection field has a non-nullable discountCode field."");
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            em.remove(discountCode);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public List<DiscountCode> findDiscountCodeEntities() {
        return findDiscountCodeEntities(true, -1, -1);
    }

    public List<DiscountCode> findDiscountCodeEntities(int maxResults, int firstResult) {
        return findDiscountCodeEntities(false, maxResults, firstResult);
    }

    private List<DiscountCode> findDiscountCodeEntities(boolean all, int maxResults, int firstResult) {
        EntityManager em = getEntityManager();
        try {
            Query q = em.createQuery(""select object(o) from DiscountCode as o"");
            if (!all) {
                q.setMaxResults(maxResults);
                q.setFirstResult(firstResult);
            }
            return q.getResultList();
        } finally {
            em.close();
        }
    }

    public DiscountCode findDiscountCode(Character id) {
        EntityManager em = getEntityManager();
        try {
            return em.find(DiscountCode.class, id);
        } finally {
            em.close();
        }
    }

    public int getDiscountCodeCount() {
        EntityManager em = getEntityManager();
        try {
            return ((Long) em.createQuery(""select count(o) from DiscountCode as o"").getSingleResult()).intValue();
        } finally {
            em.close();
        }
    }

}
"
8885695547366835973,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\ManufacturerJpaController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.controllers;

import java.util.List;
import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.EntityNotFoundException;
import javax.transaction.UserTransaction;
import jpa.controllers.exceptions.IllegalOrphanException;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.PreexistingEntityException;
import jpa.controllers.exceptions.RollbackFailureException;
import jpa.entities.Manufacturer;
import jpa.entities.Product;
import java.util.ArrayList;
import java.util.Collection;

/**
 *
 * @author mbohm
 */
public class ManufacturerJpaController {
    @Resource
    private UserTransaction utx = null;
    @PersistenceUnit(unitName = ""JsfJpaCrudPU"")
    private EntityManagerFactory emf = null;

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void create(Manufacturer manufacturer) throws PreexistingEntityException, RollbackFailureException, Exception {
        if (manufacturer.getProductCollection() == null) {
            manufacturer.setProductCollection(new ArrayList<Product>());
        }
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            List<Product> attachedProductCollection = new ArrayList<Product>();
            for (Product productCollectionProductToAttach : manufacturer.getProductCollection()) {
                productCollectionProductToAttach = em.getReference(productCollectionProductToAttach.getClass(), productCollectionProductToAttach.getProductId());
                attachedProductCollection.add(productCollectionProductToAttach);
            }
            manufacturer.setProductCollection(attachedProductCollection);
            em.persist(manufacturer);
            for (Product productCollectionProduct : manufacturer.getProductCollection()) {
                Manufacturer oldManufacturerIdOfProductCollectionProduct = productCollectionProduct.getManufacturerId();
                productCollectionProduct.setManufacturerId(manufacturer);
                productCollectionProduct = em.merge(productCollectionProduct);
                if (oldManufacturerIdOfProductCollectionProduct != null) {
                    oldManufacturerIdOfProductCollectionProduct.getProductCollection().remove(productCollectionProduct);
                    oldManufacturerIdOfProductCollectionProduct = em.merge(oldManufacturerIdOfProductCollectionProduct);
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            if (findManufacturer(manufacturer.getManufacturerId()) != null) {
                throw new PreexistingEntityException(""Manufacturer "" + manufacturer + "" already exists."", ex);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void edit(Manufacturer manufacturer) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Manufacturer persistentManufacturer = em.find(Manufacturer.class, manufacturer.getManufacturerId());
            Collection<Product> productCollectionOld = persistentManufacturer.getProductCollection();
            Collection<Product> productCollectionNew = manufacturer.getProductCollection();
            List<String> illegalOrphanMessages = null;
            for (Product productCollectionOldProduct : productCollectionOld) {
                if (!productCollectionNew.contains(productCollectionOldProduct)) {
                    if (illegalOrphanMessages == null) {
                        illegalOrphanMessages = new ArrayList<String>();
                    }
                    illegalOrphanMessages.add(""You must retain Product "" + productCollectionOldProduct + "" since its manufacturerId field is not nullable."");
                }
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            List<Product> attachedProductCollectionNew = new ArrayList<Product>();
            for (Product productCollectionNewProductToAttach : productCollectionNew) {
                productCollectionNewProductToAttach = em.getReference(productCollectionNewProductToAttach.getClass(), productCollectionNewProductToAttach.getProductId());
                attachedProductCollectionNew.add(productCollectionNewProductToAttach);
            }
            productCollectionNew = attachedProductCollectionNew;
            manufacturer.setProductCollection(productCollectionNew);
            manufacturer = em.merge(manufacturer);
            for (Product productCollectionNewProduct : productCollectionNew) {
                if (!productCollectionOld.contains(productCollectionNewProduct)) {
                    Manufacturer oldManufacturerIdOfProductCollectionNewProduct = productCollectionNewProduct.getManufacturerId();
                    productCollectionNewProduct.setManufacturerId(manufacturer);
                    productCollectionNewProduct = em.merge(productCollectionNewProduct);
                    if (oldManufacturerIdOfProductCollectionNewProduct != null && !oldManufacturerIdOfProductCollectionNewProduct.equals(manufacturer)) {
                        oldManufacturerIdOfProductCollectionNewProduct.getProductCollection().remove(productCollectionNewProduct);
                        oldManufacturerIdOfProductCollectionNewProduct = em.merge(oldManufacturerIdOfProductCollectionNewProduct);
                    }
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            String msg = ex.getLocalizedMessage();
            if (msg == null || msg.length() == 0) {
                Integer id = manufacturer.getManufacturerId();
                if (findManufacturer(id) == null) {
                    throw new NonexistentEntityException(""The manufacturer with id "" + id + "" no longer exists."");
                }
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void destroy(Integer id) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Manufacturer manufacturer;
            try {
                manufacturer = em.getReference(Manufacturer.class, id);
                manufacturer.getManufacturerId();
            } catch (EntityNotFoundException enfe) {
                throw new NonexistentEntityException(""The manufacturer with id "" + id + "" no longer exists."", enfe);
            }
            List<String> illegalOrphanMessages = null;
            Collection<Product> productCollectionOrphanCheck = manufacturer.getProductCollection();
            for (Product productCollectionOrphanCheckProduct : productCollectionOrphanCheck) {
                if (illegalOrphanMessages == null) {
                    illegalOrphanMessages = new ArrayList<String>();
                }
                illegalOrphanMessages.add(""This Manufacturer ("" + manufacturer + "") cannot be destroyed since the Product "" + productCollectionOrphanCheckProduct + "" in its productCollection field has a non-nullable manufacturerId field."");
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            em.remove(manufacturer);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public List<Manufacturer> findManufacturerEntities() {
        return findManufacturerEntities(true, -1, -1);
    }

    public List<Manufacturer> findManufacturerEntities(int maxResults, int firstResult) {
        return findManufacturerEntities(false, maxResults, firstResult);
    }

    private List<Manufacturer> findManufacturerEntities(boolean all, int maxResults, int firstResult) {
        EntityManager em = getEntityManager();
        try {
            Query q = em.createQuery(""select object(o) from Manufacturer as o"");
            if (!all) {
                q.setMaxResults(maxResults);
                q.setFirstResult(firstResult);
            }
            return q.getResultList();
        } finally {
            em.close();
        }
    }

    public Manufacturer findManufacturer(Integer id) {
        EntityManager em = getEntityManager();
        try {
            return em.find(Manufacturer.class, id);
        } finally {
            em.close();
        }
    }

    public int getManufacturerCount() {
        EntityManager em = getEntityManager();
        try {
            return ((Long) em.createQuery(""select count(o) from Manufacturer as o"").getSingleResult()).intValue();
        } finally {
            em.close();
        }
    }

}
"
1524703567102557493,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\MicroMarketJpaController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.controllers;

import java.util.List;
import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.EntityNotFoundException;
import javax.transaction.UserTransaction;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.PreexistingEntityException;
import jpa.controllers.exceptions.RollbackFailureException;
import jpa.entities.MicroMarket;

/**
 *
 * @author mbohm
 */
public class MicroMarketJpaController {
    @Resource
    private UserTransaction utx = null;
    @PersistenceUnit(unitName = ""JsfJpaCrudPU"")
    private EntityManagerFactory emf = null;

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void create(MicroMarket microMarket) throws PreexistingEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            em.persist(microMarket);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            if (findMicroMarket(microMarket.getZipCode()) != null) {
                throw new PreexistingEntityException(""MicroMarket "" + microMarket + "" already exists."", ex);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void edit(MicroMarket microMarket) throws NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            microMarket = em.merge(microMarket);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            String msg = ex.getLocalizedMessage();
            if (msg == null || msg.length() == 0) {
                String id = microMarket.getZipCode();
                if (findMicroMarket(id) == null) {
                    throw new NonexistentEntityException(""The microMarket with id "" + id + "" no longer exists."");
                }
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void destroy(String id) throws NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            MicroMarket microMarket;
            try {
                microMarket = em.getReference(MicroMarket.class, id);
                microMarket.getZipCode();
            } catch (EntityNotFoundException enfe) {
                throw new NonexistentEntityException(""The microMarket with id "" + id + "" no longer exists."", enfe);
            }
            em.remove(microMarket);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public List<MicroMarket> findMicroMarketEntities() {
        return findMicroMarketEntities(true, -1, -1);
    }

    public List<MicroMarket> findMicroMarketEntities(int maxResults, int firstResult) {
        return findMicroMarketEntities(false, maxResults, firstResult);
    }

    private List<MicroMarket> findMicroMarketEntities(boolean all, int maxResults, int firstResult) {
        EntityManager em = getEntityManager();
        try {
            Query q = em.createQuery(""select object(o) from MicroMarket as o"");
            if (!all) {
                q.setMaxResults(maxResults);
                q.setFirstResult(firstResult);
            }
            return q.getResultList();
        } finally {
            em.close();
        }
    }

    public MicroMarket findMicroMarket(String id) {
        EntityManager em = getEntityManager();
        try {
            return em.find(MicroMarket.class, id);
        } finally {
            em.close();
        }
    }

    public int getMicroMarketCount() {
        EntityManager em = getEntityManager();
        try {
            return ((Long) em.createQuery(""select count(o) from MicroMarket as o"").getSingleResult()).intValue();
        } finally {
            em.close();
        }
    }

}
"
8037329264672286202,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\ProductCodeJpaController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.controllers;

import java.util.List;
import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.EntityNotFoundException;
import javax.transaction.UserTransaction;
import jpa.controllers.exceptions.IllegalOrphanException;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.PreexistingEntityException;
import jpa.controllers.exceptions.RollbackFailureException;
import jpa.entities.Product;
import java.util.ArrayList;
import java.util.Collection;
import jpa.entities.ProductCode;

/**
 *
 * @author mbohm
 */
public class ProductCodeJpaController {
    @Resource
    private UserTransaction utx = null;
    @PersistenceUnit(unitName = ""JsfJpaCrudPU"")
    private EntityManagerFactory emf = null;

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void create(ProductCode productCode) throws PreexistingEntityException, RollbackFailureException, Exception {
        if (productCode.getProductCollection() == null) {
            productCode.setProductCollection(new ArrayList<Product>());
        }
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            List<Product> attachedProductCollection = new ArrayList<Product>();
            for (Product productCollectionProductToAttach : productCode.getProductCollection()) {
                productCollectionProductToAttach = em.getReference(productCollectionProductToAttach.getClass(), productCollectionProductToAttach.getProductId());
                attachedProductCollection.add(productCollectionProductToAttach);
            }
            productCode.setProductCollection(attachedProductCollection);
            em.persist(productCode);
            for (Product productCollectionProduct : productCode.getProductCollection()) {
                ProductCode oldProductCodeOfProductCollectionProduct = productCollectionProduct.getProductCode();
                productCollectionProduct.setProductCode(productCode);
                productCollectionProduct = em.merge(productCollectionProduct);
                if (oldProductCodeOfProductCollectionProduct != null) {
                    oldProductCodeOfProductCollectionProduct.getProductCollection().remove(productCollectionProduct);
                    oldProductCodeOfProductCollectionProduct = em.merge(oldProductCodeOfProductCollectionProduct);
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            if (findProductCode(productCode.getProdCode()) != null) {
                throw new PreexistingEntityException(""ProductCode "" + productCode + "" already exists."", ex);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void edit(ProductCode productCode) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            ProductCode persistentProductCode = em.find(ProductCode.class, productCode.getProdCode());
            Collection<Product> productCollectionOld = persistentProductCode.getProductCollection();
            Collection<Product> productCollectionNew = productCode.getProductCollection();
            List<String> illegalOrphanMessages = null;
            for (Product productCollectionOldProduct : productCollectionOld) {
                if (!productCollectionNew.contains(productCollectionOldProduct)) {
                    if (illegalOrphanMessages == null) {
                        illegalOrphanMessages = new ArrayList<String>();
                    }
                    illegalOrphanMessages.add(""You must retain Product "" + productCollectionOldProduct + "" since its productCode field is not nullable."");
                }
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            List<Product> attachedProductCollectionNew = new ArrayList<Product>();
            for (Product productCollectionNewProductToAttach : productCollectionNew) {
                productCollectionNewProductToAttach = em.getReference(productCollectionNewProductToAttach.getClass(), productCollectionNewProductToAttach.getProductId());
                attachedProductCollectionNew.add(productCollectionNewProductToAttach);
            }
            productCollectionNew = attachedProductCollectionNew;
            productCode.setProductCollection(productCollectionNew);
            productCode = em.merge(productCode);
            for (Product productCollectionNewProduct : productCollectionNew) {
                if (!productCollectionOld.contains(productCollectionNewProduct)) {
                    ProductCode oldProductCodeOfProductCollectionNewProduct = productCollectionNewProduct.getProductCode();
                    productCollectionNewProduct.setProductCode(productCode);
                    productCollectionNewProduct = em.merge(productCollectionNewProduct);
                    if (oldProductCodeOfProductCollectionNewProduct != null && !oldProductCodeOfProductCollectionNewProduct.equals(productCode)) {
                        oldProductCodeOfProductCollectionNewProduct.getProductCollection().remove(productCollectionNewProduct);
                        oldProductCodeOfProductCollectionNewProduct = em.merge(oldProductCodeOfProductCollectionNewProduct);
                    }
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            String msg = ex.getLocalizedMessage();
            if (msg == null || msg.length() == 0) {
                String id = productCode.getProdCode();
                if (findProductCode(id) == null) {
                    throw new NonexistentEntityException(""The productCode with id "" + id + "" no longer exists."");
                }
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void destroy(String id) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            ProductCode productCode;
            try {
                productCode = em.getReference(ProductCode.class, id);
                productCode.getProdCode();
            } catch (EntityNotFoundException enfe) {
                throw new NonexistentEntityException(""The productCode with id "" + id + "" no longer exists."", enfe);
            }
            List<String> illegalOrphanMessages = null;
            Collection<Product> productCollectionOrphanCheck = productCode.getProductCollection();
            for (Product productCollectionOrphanCheckProduct : productCollectionOrphanCheck) {
                if (illegalOrphanMessages == null) {
                    illegalOrphanMessages = new ArrayList<String>();
                }
                illegalOrphanMessages.add(""This ProductCode ("" + productCode + "") cannot be destroyed since the Product "" + productCollectionOrphanCheckProduct + "" in its productCollection field has a non-nullable productCode field."");
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            em.remove(productCode);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public List<ProductCode> findProductCodeEntities() {
        return findProductCodeEntities(true, -1, -1);
    }

    public List<ProductCode> findProductCodeEntities(int maxResults, int firstResult) {
        return findProductCodeEntities(false, maxResults, firstResult);
    }

    private List<ProductCode> findProductCodeEntities(boolean all, int maxResults, int firstResult) {
        EntityManager em = getEntityManager();
        try {
            Query q = em.createQuery(""select object(o) from ProductCode as o"");
            if (!all) {
                q.setMaxResults(maxResults);
                q.setFirstResult(firstResult);
            }
            return q.getResultList();
        } finally {
            em.close();
        }
    }

    public ProductCode findProductCode(String id) {
        EntityManager em = getEntityManager();
        try {
            return em.find(ProductCode.class, id);
        } finally {
            em.close();
        }
    }

    public int getProductCodeCount() {
        EntityManager em = getEntityManager();
        try {
            return ((Long) em.createQuery(""select count(o) from ProductCode as o"").getSingleResult()).intValue();
        } finally {
            em.close();
        }
    }

}
"
-4802753870994409689,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\ProductJpaController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.controllers;

import java.util.List;
import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.EntityNotFoundException;
import javax.transaction.UserTransaction;
import jpa.controllers.exceptions.IllegalOrphanException;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.PreexistingEntityException;
import jpa.controllers.exceptions.RollbackFailureException;
import jpa.entities.Manufacturer;
import jpa.entities.Product;
import jpa.entities.ProductCode;
import jpa.entities.PurchaseOrder;
import java.util.ArrayList;
import java.util.Collection;

/**
 *
 * @author mbohm
 */
public class ProductJpaController {
    @Resource
    private UserTransaction utx = null;
    @PersistenceUnit(unitName = ""JsfJpaCrudPU"")
    private EntityManagerFactory emf = null;

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void create(Product product) throws PreexistingEntityException, RollbackFailureException, Exception {
        if (product.getPurchaseOrderCollection() == null) {
            product.setPurchaseOrderCollection(new ArrayList<PurchaseOrder>());
        }
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Manufacturer manufacturerId = product.getManufacturerId();
            if (manufacturerId != null) {
                manufacturerId = em.getReference(manufacturerId.getClass(), manufacturerId.getManufacturerId());
                product.setManufacturerId(manufacturerId);
            }
            ProductCode productCode = product.getProductCode();
            if (productCode != null) {
                productCode = em.getReference(productCode.getClass(), productCode.getProdCode());
                product.setProductCode(productCode);
            }
            List<PurchaseOrder> attachedPurchaseOrderCollection = new ArrayList<PurchaseOrder>();
            for (PurchaseOrder purchaseOrderCollectionPurchaseOrderToAttach : product.getPurchaseOrderCollection()) {
                purchaseOrderCollectionPurchaseOrderToAttach = em.getReference(purchaseOrderCollectionPurchaseOrderToAttach.getClass(), purchaseOrderCollectionPurchaseOrderToAttach.getOrderNum());
                attachedPurchaseOrderCollection.add(purchaseOrderCollectionPurchaseOrderToAttach);
            }
            product.setPurchaseOrderCollection(attachedPurchaseOrderCollection);
            em.persist(product);
            if (manufacturerId != null) {
                manufacturerId.getProductCollection().add(product);
                manufacturerId = em.merge(manufacturerId);
            }
            if (productCode != null) {
                productCode.getProductCollection().add(product);
                productCode = em.merge(productCode);
            }
            for (PurchaseOrder purchaseOrderCollectionPurchaseOrder : product.getPurchaseOrderCollection()) {
                Product oldProductIdOfPurchaseOrderCollectionPurchaseOrder = purchaseOrderCollectionPurchaseOrder.getProductId();
                purchaseOrderCollectionPurchaseOrder.setProductId(product);
                purchaseOrderCollectionPurchaseOrder = em.merge(purchaseOrderCollectionPurchaseOrder);
                if (oldProductIdOfPurchaseOrderCollectionPurchaseOrder != null) {
                    oldProductIdOfPurchaseOrderCollectionPurchaseOrder.getPurchaseOrderCollection().remove(purchaseOrderCollectionPurchaseOrder);
                    oldProductIdOfPurchaseOrderCollectionPurchaseOrder = em.merge(oldProductIdOfPurchaseOrderCollectionPurchaseOrder);
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            if (findProduct(product.getProductId()) != null) {
                throw new PreexistingEntityException(""Product "" + product + "" already exists."", ex);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void edit(Product product) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Product persistentProduct = em.find(Product.class, product.getProductId());
            Manufacturer manufacturerIdOld = persistentProduct.getManufacturerId();
            Manufacturer manufacturerIdNew = product.getManufacturerId();
            ProductCode productCodeOld = persistentProduct.getProductCode();
            ProductCode productCodeNew = product.getProductCode();
            Collection<PurchaseOrder> purchaseOrderCollectionOld = persistentProduct.getPurchaseOrderCollection();
            Collection<PurchaseOrder> purchaseOrderCollectionNew = product.getPurchaseOrderCollection();
            List<String> illegalOrphanMessages = null;
            for (PurchaseOrder purchaseOrderCollectionOldPurchaseOrder : purchaseOrderCollectionOld) {
                if (!purchaseOrderCollectionNew.contains(purchaseOrderCollectionOldPurchaseOrder)) {
                    if (illegalOrphanMessages == null) {
                        illegalOrphanMessages = new ArrayList<String>();
                    }
                    illegalOrphanMessages.add(""You must retain PurchaseOrder "" + purchaseOrderCollectionOldPurchaseOrder + "" since its productId field is not nullable."");
                }
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            if (manufacturerIdNew != null) {
                manufacturerIdNew = em.getReference(manufacturerIdNew.getClass(), manufacturerIdNew.getManufacturerId());
                product.setManufacturerId(manufacturerIdNew);
            }
            if (productCodeNew != null) {
                productCodeNew = em.getReference(productCodeNew.getClass(), productCodeNew.getProdCode());
                product.setProductCode(productCodeNew);
            }
            List<PurchaseOrder> attachedPurchaseOrderCollectionNew = new ArrayList<PurchaseOrder>();
            for (PurchaseOrder purchaseOrderCollectionNewPurchaseOrderToAttach : purchaseOrderCollectionNew) {
                purchaseOrderCollectionNewPurchaseOrderToAttach = em.getReference(purchaseOrderCollectionNewPurchaseOrderToAttach.getClass(), purchaseOrderCollectionNewPurchaseOrderToAttach.getOrderNum());
                attachedPurchaseOrderCollectionNew.add(purchaseOrderCollectionNewPurchaseOrderToAttach);
            }
            purchaseOrderCollectionNew = attachedPurchaseOrderCollectionNew;
            product.setPurchaseOrderCollection(purchaseOrderCollectionNew);
            product = em.merge(product);
            if (manufacturerIdOld != null && !manufacturerIdOld.equals(manufacturerIdNew)) {
                manufacturerIdOld.getProductCollection().remove(product);
                manufacturerIdOld = em.merge(manufacturerIdOld);
            }
            if (manufacturerIdNew != null && !manufacturerIdNew.equals(manufacturerIdOld)) {
                manufacturerIdNew.getProductCollection().add(product);
                manufacturerIdNew = em.merge(manufacturerIdNew);
            }
            if (productCodeOld != null && !productCodeOld.equals(productCodeNew)) {
                productCodeOld.getProductCollection().remove(product);
                productCodeOld = em.merge(productCodeOld);
            }
            if (productCodeNew != null && !productCodeNew.equals(productCodeOld)) {
                productCodeNew.getProductCollection().add(product);
                productCodeNew = em.merge(productCodeNew);
            }
            for (PurchaseOrder purchaseOrderCollectionNewPurchaseOrder : purchaseOrderCollectionNew) {
                if (!purchaseOrderCollectionOld.contains(purchaseOrderCollectionNewPurchaseOrder)) {
                    Product oldProductIdOfPurchaseOrderCollectionNewPurchaseOrder = purchaseOrderCollectionNewPurchaseOrder.getProductId();
                    purchaseOrderCollectionNewPurchaseOrder.setProductId(product);
                    purchaseOrderCollectionNewPurchaseOrder = em.merge(purchaseOrderCollectionNewPurchaseOrder);
                    if (oldProductIdOfPurchaseOrderCollectionNewPurchaseOrder != null && !oldProductIdOfPurchaseOrderCollectionNewPurchaseOrder.equals(product)) {
                        oldProductIdOfPurchaseOrderCollectionNewPurchaseOrder.getPurchaseOrderCollection().remove(purchaseOrderCollectionNewPurchaseOrder);
                        oldProductIdOfPurchaseOrderCollectionNewPurchaseOrder = em.merge(oldProductIdOfPurchaseOrderCollectionNewPurchaseOrder);
                    }
                }
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            String msg = ex.getLocalizedMessage();
            if (msg == null || msg.length() == 0) {
                Integer id = product.getProductId();
                if (findProduct(id) == null) {
                    throw new NonexistentEntityException(""The product with id "" + id + "" no longer exists."");
                }
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void destroy(Integer id) throws IllegalOrphanException, NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Product product;
            try {
                product = em.getReference(Product.class, id);
                product.getProductId();
            } catch (EntityNotFoundException enfe) {
                throw new NonexistentEntityException(""The product with id "" + id + "" no longer exists."", enfe);
            }
            List<String> illegalOrphanMessages = null;
            Collection<PurchaseOrder> purchaseOrderCollectionOrphanCheck = product.getPurchaseOrderCollection();
            for (PurchaseOrder purchaseOrderCollectionOrphanCheckPurchaseOrder : purchaseOrderCollectionOrphanCheck) {
                if (illegalOrphanMessages == null) {
                    illegalOrphanMessages = new ArrayList<String>();
                }
                illegalOrphanMessages.add(""This Product ("" + product + "") cannot be destroyed since the PurchaseOrder "" + purchaseOrderCollectionOrphanCheckPurchaseOrder + "" in its purchaseOrderCollection field has a non-nullable productId field."");
            }
            if (illegalOrphanMessages != null) {
                throw new IllegalOrphanException(illegalOrphanMessages);
            }
            Manufacturer manufacturerId = product.getManufacturerId();
            if (manufacturerId != null) {
                manufacturerId.getProductCollection().remove(product);
                manufacturerId = em.merge(manufacturerId);
            }
            ProductCode productCode = product.getProductCode();
            if (productCode != null) {
                productCode.getProductCollection().remove(product);
                productCode = em.merge(productCode);
            }
            em.remove(product);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public List<Product> findProductEntities() {
        return findProductEntities(true, -1, -1);
    }

    public List<Product> findProductEntities(int maxResults, int firstResult) {
        return findProductEntities(false, maxResults, firstResult);
    }

    private List<Product> findProductEntities(boolean all, int maxResults, int firstResult) {
        EntityManager em = getEntityManager();
        try {
            Query q = em.createQuery(""select object(o) from Product as o"");
            if (!all) {
                q.setMaxResults(maxResults);
                q.setFirstResult(firstResult);
            }
            return q.getResultList();
        } finally {
            em.close();
        }
    }

    public Product findProduct(Integer id) {
        EntityManager em = getEntityManager();
        try {
            return em.find(Product.class, id);
        } finally {
            em.close();
        }
    }

    public int getProductCount() {
        EntityManager em = getEntityManager();
        try {
            return ((Long) em.createQuery(""select count(o) from Product as o"").getSingleResult()).intValue();
        } finally {
            em.close();
        }
    }

}
"
-5132524465796680136,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\PurchaseOrderJpaController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.controllers;

import java.util.List;
import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.PersistenceUnit;
import javax.persistence.Query;
import javax.persistence.EntityNotFoundException;
import javax.transaction.UserTransaction;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.PreexistingEntityException;
import jpa.controllers.exceptions.RollbackFailureException;
import jpa.entities.Customer;
import jpa.entities.Product;
import jpa.entities.PurchaseOrder;

/**
 *
 * @author mbohm
 */
public class PurchaseOrderJpaController {
    @Resource
    private UserTransaction utx = null;
    @PersistenceUnit(unitName = ""JsfJpaCrudPU"")
    private EntityManagerFactory emf = null;

    public EntityManager getEntityManager() {
        return emf.createEntityManager();
    }

    public void create(PurchaseOrder purchaseOrder) throws PreexistingEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            Customer customerId = purchaseOrder.getCustomerId();
            if (customerId != null) {
                customerId = em.getReference(customerId.getClass(), customerId.getCustomerId());
                purchaseOrder.setCustomerId(customerId);
            }
            Product productId = purchaseOrder.getProductId();
            if (productId != null) {
                productId = em.getReference(productId.getClass(), productId.getProductId());
                purchaseOrder.setProductId(productId);
            }
            em.persist(purchaseOrder);
            if (customerId != null) {
                customerId.getPurchaseOrderCollection().add(purchaseOrder);
                customerId = em.merge(customerId);
            }
            if (productId != null) {
                productId.getPurchaseOrderCollection().add(purchaseOrder);
                productId = em.merge(productId);
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            if (findPurchaseOrder(purchaseOrder.getOrderNum()) != null) {
                throw new PreexistingEntityException(""PurchaseOrder "" + purchaseOrder + "" already exists."", ex);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void edit(PurchaseOrder purchaseOrder) throws NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            PurchaseOrder persistentPurchaseOrder = em.find(PurchaseOrder.class, purchaseOrder.getOrderNum());
            Customer customerIdOld = persistentPurchaseOrder.getCustomerId();
            Customer customerIdNew = purchaseOrder.getCustomerId();
            Product productIdOld = persistentPurchaseOrder.getProductId();
            Product productIdNew = purchaseOrder.getProductId();
            if (customerIdNew != null) {
                customerIdNew = em.getReference(customerIdNew.getClass(), customerIdNew.getCustomerId());
                purchaseOrder.setCustomerId(customerIdNew);
            }
            if (productIdNew != null) {
                productIdNew = em.getReference(productIdNew.getClass(), productIdNew.getProductId());
                purchaseOrder.setProductId(productIdNew);
            }
            purchaseOrder = em.merge(purchaseOrder);
            if (customerIdOld != null && !customerIdOld.equals(customerIdNew)) {
                customerIdOld.getPurchaseOrderCollection().remove(purchaseOrder);
                customerIdOld = em.merge(customerIdOld);
            }
            if (customerIdNew != null && !customerIdNew.equals(customerIdOld)) {
                customerIdNew.getPurchaseOrderCollection().add(purchaseOrder);
                customerIdNew = em.merge(customerIdNew);
            }
            if (productIdOld != null && !productIdOld.equals(productIdNew)) {
                productIdOld.getPurchaseOrderCollection().remove(purchaseOrder);
                productIdOld = em.merge(productIdOld);
            }
            if (productIdNew != null && !productIdNew.equals(productIdOld)) {
                productIdNew.getPurchaseOrderCollection().add(purchaseOrder);
                productIdNew = em.merge(productIdNew);
            }
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            String msg = ex.getLocalizedMessage();
            if (msg == null || msg.length() == 0) {
                Integer id = purchaseOrder.getOrderNum();
                if (findPurchaseOrder(id) == null) {
                    throw new NonexistentEntityException(""The purchaseOrder with id "" + id + "" no longer exists."");
                }
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public void destroy(Integer id) throws NonexistentEntityException, RollbackFailureException, Exception {
        EntityManager em = null;
        try {
            utx.begin();
            em = getEntityManager();
            PurchaseOrder purchaseOrder;
            try {
                purchaseOrder = em.getReference(PurchaseOrder.class, id);
                purchaseOrder.getOrderNum();
            } catch (EntityNotFoundException enfe) {
                throw new NonexistentEntityException(""The purchaseOrder with id "" + id + "" no longer exists."", enfe);
            }
            Customer customerId = purchaseOrder.getCustomerId();
            if (customerId != null) {
                customerId.getPurchaseOrderCollection().remove(purchaseOrder);
                customerId = em.merge(customerId);
            }
            Product productId = purchaseOrder.getProductId();
            if (productId != null) {
                productId.getPurchaseOrderCollection().remove(purchaseOrder);
                productId = em.merge(productId);
            }
            em.remove(purchaseOrder);
            utx.commit();
        } catch (Exception ex) {
            try {
                utx.rollback();
            } catch (Exception re) {
                throw new RollbackFailureException(""An error occurred attempting to roll back the transaction."", re);
            }
            throw ex;
        } finally {
            if (em != null) {
                em.close();
            }
        }
    }

    public List<PurchaseOrder> findPurchaseOrderEntities() {
        return findPurchaseOrderEntities(true, -1, -1);
    }

    public List<PurchaseOrder> findPurchaseOrderEntities(int maxResults, int firstResult) {
        return findPurchaseOrderEntities(false, maxResults, firstResult);
    }

    private List<PurchaseOrder> findPurchaseOrderEntities(boolean all, int maxResults, int firstResult) {
        EntityManager em = getEntityManager();
        try {
            Query q = em.createQuery(""select object(o) from PurchaseOrder as o"");
            if (!all) {
                q.setMaxResults(maxResults);
                q.setFirstResult(firstResult);
            }
            return q.getResultList();
        } finally {
            em.close();
        }
    }

    public PurchaseOrder findPurchaseOrder(Integer id) {
        EntityManager em = getEntityManager();
        try {
            return em.find(PurchaseOrder.class, id);
        } finally {
            em.close();
        }
    }

    public int getPurchaseOrderCount() {
        EntityManager em = getEntityManager();
        try {
            return ((Long) em.createQuery(""select count(o) from PurchaseOrder as o"").getSingleResult()).intValue();
        } finally {
            em.close();
        }
    }

}
"
3924894767219805736,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\exceptions\IllegalOrphanException.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jpa.controllers.exceptions;

import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author mbohm
 */
public class IllegalOrphanException extends Exception {
    private List<String> messages;
    public IllegalOrphanException(List<String> messages) {
        super((messages != null && messages.size() > 0 ? messages.get(0) : null));
        if (messages == null) {
            this.messages = new ArrayList<String>();
        }
        else {
            this.messages = messages;
        }
    }
    public List<String> getMessages() {
        return messages;
    }
}
"
6110857971322732390,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\exceptions\NonexistentEntityException.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jpa.controllers.exceptions;

/**
 *
 * @author mbohm
 */
public class NonexistentEntityException extends Exception {
    public NonexistentEntityException(String message, Throwable cause) {
        super(message, cause);
    }
    public NonexistentEntityException(String message) {
        super(message);
    }
}
"
-8615212743608316172,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\exceptions\PreexistingEntityException.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jpa.controllers.exceptions;

/**
 *
 * @author mbohm
 */
public class PreexistingEntityException extends Exception {
    public PreexistingEntityException(String message, Throwable cause) {
        super(message, cause);
    }
    public PreexistingEntityException(String message) {
        super(message);
    }
}
"
7215442311499506945,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\controllers\exceptions\RollbackFailureException.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jpa.controllers.exceptions;

/**
 *
 * @author mbohm
 */
public class RollbackFailureException extends Exception {
    public RollbackFailureException(String message, Throwable cause) {
        super(message, cause);
    }
    public RollbackFailureException(String message) {
        super(message);
    }
}
"
2603643474343528410,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\entities\Customer.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.entities;

import java.io.Serializable;
import java.util.Collection;
import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;

/**
 *
 * @author mbohm
 */
@Entity
@Table(name = ""CUSTOMER"")
@NamedQueries({@NamedQuery(name = ""Customer.findAll"", query = ""SELECT c FROM Customer c""), @NamedQuery(name = ""Customer.findByCustomerId"", query = ""SELECT c FROM Customer c WHERE c.customerId = :customerId""), @NamedQuery(name = ""Customer.findByZip"", query = ""SELECT c FROM Customer c WHERE c.zip = :zip""), @NamedQuery(name = ""Customer.findByName"", query = ""SELECT c FROM Customer c WHERE c.name = :name""), @NamedQuery(name = ""Customer.findByAddressline1"", query = ""SELECT c FROM Customer c WHERE c.addressline1 = :addressline1""), @NamedQuery(name = ""Customer.findByAddressline2"", query = ""SELECT c FROM Customer c WHERE c.addressline2 = :addressline2""), @NamedQuery(name = ""Customer.findByCity"", query = ""SELECT c FROM Customer c WHERE c.city = :city""), @NamedQuery(name = ""Customer.findByState"", query = ""SELECT c FROM Customer c WHERE c.state = :state""), @NamedQuery(name = ""Customer.findByPhone"", query = ""SELECT c FROM Customer c WHERE c.phone = :phone""), @NamedQuery(name = ""Customer.findByFax"", query = ""SELECT c FROM Customer c WHERE c.fax = :fax""), @NamedQuery(name = ""Customer.findByEmail"", query = ""SELECT c FROM Customer c WHERE c.email = :email""), @NamedQuery(name = ""Customer.findByCreditLimit"", query = ""SELECT c FROM Customer c WHERE c.creditLimit = :creditLimit"")})
public class Customer implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @Basic(optional = false)
    @Column(name = ""CUSTOMER_ID"")
    private Integer customerId;
    @Basic(optional = false)
    @Column(name = ""ZIP"")
    private String zip;
    @Column(name = ""NAME"")
    private String name;
    @Column(name = ""ADDRESSLINE1"")
    private String addressline1;
    @Column(name = ""ADDRESSLINE2"")
    private String addressline2;
    @Column(name = ""CITY"")
    private String city;
    @Column(name = ""STATE"")
    private String state;
    @Column(name = ""PHONE"")
    private String phone;
    @Column(name = ""FAX"")
    private String fax;
    @Column(name = ""EMAIL"")
    private String email;
    @Column(name = ""CREDIT_LIMIT"")
    private Integer creditLimit;
    @JoinColumn(name = ""DISCOUNT_CODE"", referencedColumnName = ""DISCOUNT_CODE"")
    @ManyToOne(optional = false)
    private DiscountCode discountCode;
    @OneToMany(cascade = CascadeType.ALL, mappedBy = ""customerId"")
    private Collection<PurchaseOrder> purchaseOrderCollection;

    public Customer() {
    }

    public Customer(Integer customerId) {
        this.customerId = customerId;
    }

    public Customer(Integer customerId, String zip) {
        this.customerId = customerId;
        this.zip = zip;
    }

    public Integer getCustomerId() {
        return customerId;
    }

    public void setCustomerId(Integer customerId) {
        this.customerId = customerId;
    }

    public String getZip() {
        return zip;
    }

    public void setZip(String zip) {
        this.zip = zip;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getFax() {
        return fax;
    }

    public void setFax(String fax) {
        this.fax = fax;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Integer getCreditLimit() {
        return creditLimit;
    }

    public void setCreditLimit(Integer creditLimit) {
        this.creditLimit = creditLimit;
    }

    public DiscountCode getDiscountCode() {
        return discountCode;
    }

    public void setDiscountCode(DiscountCode discountCode) {
        this.discountCode = discountCode;
    }

    public Collection<PurchaseOrder> getPurchaseOrderCollection() {
        return purchaseOrderCollection;
    }

    public void setPurchaseOrderCollection(Collection<PurchaseOrder> purchaseOrderCollection) {
        this.purchaseOrderCollection = purchaseOrderCollection;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (customerId != null ? customerId.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof Customer)) {
            return false;
        }
        Customer other = (Customer) object;
        if ((this.customerId == null && other.customerId != null) || (this.customerId != null && !this.customerId.equals(other.customerId))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return customerId.toString();
    }

}
"
159679259342681289,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\entities\DiscountCode.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.entities;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Collection;
import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;

/**
 *
 * @author mbohm
 */
@Entity
@Table(name = ""DISCOUNT_CODE"")
@NamedQueries({@NamedQuery(name = ""DiscountCode.findAll"", query = ""SELECT d FROM DiscountCode d""), @NamedQuery(name = ""DiscountCode.findByDiscountCode"", query = ""SELECT d FROM DiscountCode d WHERE d.discountCode = :discountCode""), @NamedQuery(name = ""DiscountCode.findByRate"", query = ""SELECT d FROM DiscountCode d WHERE d.rate = :rate"")})
public class DiscountCode implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @Basic(optional = false)
    @Column(name = ""DISCOUNT_CODE"")
    private Character discountCode;
    @Column(name = ""RATE"")
    private BigDecimal rate;
    @OneToMany(cascade = CascadeType.ALL, mappedBy = ""discountCode"")
    private Collection<Customer> customerCollection;

    public DiscountCode() {
    }

    public DiscountCode(Character discountCode) {
        this.discountCode = discountCode;
    }

    public Character getDiscountCode() {
        return discountCode;
    }

    public void setDiscountCode(Character discountCode) {
        this.discountCode = discountCode;
    }

    public BigDecimal getRate() {
        return rate;
    }

    public void setRate(BigDecimal rate) {
        this.rate = rate;
    }

    public Collection<Customer> getCustomerCollection() {
        return customerCollection;
    }

    public void setCustomerCollection(Collection<Customer> customerCollection) {
        this.customerCollection = customerCollection;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (discountCode != null ? discountCode.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof DiscountCode)) {
            return false;
        }
        DiscountCode other = (DiscountCode) object;
        if ((this.discountCode == null && other.discountCode != null) || (this.discountCode != null && !this.discountCode.equals(other.discountCode))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return discountCode.toString();
    }

}
"
-8684923007596223644,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\entities\Manufacturer.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.entities;

import java.io.Serializable;
import java.util.Collection;
import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;

/**
 *
 * @author mbohm
 */
@Entity
@Table(name = ""MANUFACTURER"")
@NamedQueries({@NamedQuery(name = ""Manufacturer.findAll"", query = ""SELECT m FROM Manufacturer m""), @NamedQuery(name = ""Manufacturer.findByManufacturerId"", query = ""SELECT m FROM Manufacturer m WHERE m.manufacturerId = :manufacturerId""), @NamedQuery(name = ""Manufacturer.findByName"", query = ""SELECT m FROM Manufacturer m WHERE m.name = :name""), @NamedQuery(name = ""Manufacturer.findByAddressline1"", query = ""SELECT m FROM Manufacturer m WHERE m.addressline1 = :addressline1""), @NamedQuery(name = ""Manufacturer.findByAddressline2"", query = ""SELECT m FROM Manufacturer m WHERE m.addressline2 = :addressline2""), @NamedQuery(name = ""Manufacturer.findByCity"", query = ""SELECT m FROM Manufacturer m WHERE m.city = :city""), @NamedQuery(name = ""Manufacturer.findByState"", query = ""SELECT m FROM Manufacturer m WHERE m.state = :state""), @NamedQuery(name = ""Manufacturer.findByZip"", query = ""SELECT m FROM Manufacturer m WHERE m.zip = :zip""), @NamedQuery(name = ""Manufacturer.findByPhone"", query = ""SELECT m FROM Manufacturer m WHERE m.phone = :phone""), @NamedQuery(name = ""Manufacturer.findByFax"", query = ""SELECT m FROM Manufacturer m WHERE m.fax = :fax""), @NamedQuery(name = ""Manufacturer.findByEmail"", query = ""SELECT m FROM Manufacturer m WHERE m.email = :email""), @NamedQuery(name = ""Manufacturer.findByRep"", query = ""SELECT m FROM Manufacturer m WHERE m.rep = :rep"")})
public class Manufacturer implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @Basic(optional = false)
    @Column(name = ""MANUFACTURER_ID"")
    private Integer manufacturerId;
    @Column(name = ""NAME"")
    private String name;
    @Column(name = ""ADDRESSLINE1"")
    private String addressline1;
    @Column(name = ""ADDRESSLINE2"")
    private String addressline2;
    @Column(name = ""CITY"")
    private String city;
    @Column(name = ""STATE"")
    private String state;
    @Column(name = ""ZIP"")
    private String zip;
    @Column(name = ""PHONE"")
    private String phone;
    @Column(name = ""FAX"")
    private String fax;
    @Column(name = ""EMAIL"")
    private String email;
    @Column(name = ""REP"")
    private String rep;
    @OneToMany(cascade = CascadeType.ALL, mappedBy = ""manufacturerId"")
    private Collection<Product> productCollection;

    public Manufacturer() {
    }

    public Manufacturer(Integer manufacturerId) {
        this.manufacturerId = manufacturerId;
    }

    public Integer getManufacturerId() {
        return manufacturerId;
    }

    public void setManufacturerId(Integer manufacturerId) {
        this.manufacturerId = manufacturerId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAddressline1() {
        return addressline1;
    }

    public void setAddressline1(String addressline1) {
        this.addressline1 = addressline1;
    }

    public String getAddressline2() {
        return addressline2;
    }

    public void setAddressline2(String addressline2) {
        this.addressline2 = addressline2;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getZip() {
        return zip;
    }

    public void setZip(String zip) {
        this.zip = zip;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public String getFax() {
        return fax;
    }

    public void setFax(String fax) {
        this.fax = fax;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getRep() {
        return rep;
    }

    public void setRep(String rep) {
        this.rep = rep;
    }

    public Collection<Product> getProductCollection() {
        return productCollection;
    }

    public void setProductCollection(Collection<Product> productCollection) {
        this.productCollection = productCollection;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (manufacturerId != null ? manufacturerId.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof Manufacturer)) {
            return false;
        }
        Manufacturer other = (Manufacturer) object;
        if ((this.manufacturerId == null && other.manufacturerId != null) || (this.manufacturerId != null && !this.manufacturerId.equals(other.manufacturerId))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return manufacturerId.toString();
    }

}
"
6739430094900862177,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\entities\MicroMarket.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.entities;

import java.io.Serializable;
import javax.persistence.Basic;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

/**
 *
 * @author mbohm
 */
@Entity
@Table(name = ""MICRO_MARKET"")
@NamedQueries({@NamedQuery(name = ""MicroMarket.findAll"", query = ""SELECT m FROM MicroMarket m""), @NamedQuery(name = ""MicroMarket.findByZipCode"", query = ""SELECT m FROM MicroMarket m WHERE m.zipCode = :zipCode""), @NamedQuery(name = ""MicroMarket.findByRadius"", query = ""SELECT m FROM MicroMarket m WHERE m.radius = :radius""), @NamedQuery(name = ""MicroMarket.findByAreaLength"", query = ""SELECT m FROM MicroMarket m WHERE m.areaLength = :areaLength""), @NamedQuery(name = ""MicroMarket.findByAreaWidth"", query = ""SELECT m FROM MicroMarket m WHERE m.areaWidth = :areaWidth"")})
public class MicroMarket implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @Basic(optional = false)
    @Column(name = ""ZIP_CODE"")
    private String zipCode;
    @Column(name = ""RADIUS"")
    private Double radius;
    @Column(name = ""AREA_LENGTH"")
    private Double areaLength;
    @Column(name = ""AREA_WIDTH"")
    private Double areaWidth;

    public MicroMarket() {
    }

    public MicroMarket(String zipCode) {
        this.zipCode = zipCode;
    }

    public String getZipCode() {
        return zipCode;
    }

    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }

    public Double getRadius() {
        return radius;
    }

    public void setRadius(Double radius) {
        this.radius = radius;
    }

    public Double getAreaLength() {
        return areaLength;
    }

    public void setAreaLength(Double areaLength) {
        this.areaLength = areaLength;
    }

    public Double getAreaWidth() {
        return areaWidth;
    }

    public void setAreaWidth(Double areaWidth) {
        this.areaWidth = areaWidth;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (zipCode != null ? zipCode.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof MicroMarket)) {
            return false;
        }
        MicroMarket other = (MicroMarket) object;
        if ((this.zipCode == null && other.zipCode != null) || (this.zipCode != null && !this.zipCode.equals(other.zipCode))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return ""jpa.entities.MicroMarket[zipCode="" + zipCode + ""]"";
    }

}
"
2318893022756682314,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\entities\Product.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.entities;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Collection;
import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;

/**
 *
 * @author mbohm
 */
@Entity
@Table(name = ""PRODUCT"")
@NamedQueries({@NamedQuery(name = ""Product.findAll"", query = ""SELECT p FROM Product p""), @NamedQuery(name = ""Product.findByProductId"", query = ""SELECT p FROM Product p WHERE p.productId = :productId""), @NamedQuery(name = ""Product.findByPurchaseCost"", query = ""SELECT p FROM Product p WHERE p.purchaseCost = :purchaseCost""), @NamedQuery(name = ""Product.findByQuantityOnHand"", query = ""SELECT p FROM Product p WHERE p.quantityOnHand = :quantityOnHand""), @NamedQuery(name = ""Product.findByMarkup"", query = ""SELECT p FROM Product p WHERE p.markup = :markup""), @NamedQuery(name = ""Product.findByAvailable"", query = ""SELECT p FROM Product p WHERE p.available = :available""), @NamedQuery(name = ""Product.findByDescription"", query = ""SELECT p FROM Product p WHERE p.description = :description"")})
public class Product implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @Basic(optional = false)
    @Column(name = ""PRODUCT_ID"")
    private Integer productId;
    @Column(name = ""PURCHASE_COST"")
    private BigDecimal purchaseCost;
    @Column(name = ""QUANTITY_ON_HAND"")
    private Integer quantityOnHand;
    @Column(name = ""MARKUP"")
    private BigDecimal markup;
    @Column(name = ""AVAILABLE"")
    private String available;
    @Column(name = ""DESCRIPTION"")
    private String description;
    @JoinColumn(name = ""MANUFACTURER_ID"", referencedColumnName = ""MANUFACTURER_ID"")
    @ManyToOne(optional = false)
    private Manufacturer manufacturerId;
    @JoinColumn(name = ""PRODUCT_CODE"", referencedColumnName = ""PROD_CODE"")
    @ManyToOne(optional = false)
    private ProductCode productCode;
    @OneToMany(cascade = CascadeType.ALL, mappedBy = ""productId"")
    private Collection<PurchaseOrder> purchaseOrderCollection;

    public Product() {
    }

    public Product(Integer productId) {
        this.productId = productId;
    }

    public Integer getProductId() {
        return productId;
    }

    public void setProductId(Integer productId) {
        this.productId = productId;
    }

    public BigDecimal getPurchaseCost() {
        return purchaseCost;
    }

    public void setPurchaseCost(BigDecimal purchaseCost) {
        this.purchaseCost = purchaseCost;
    }

    public Integer getQuantityOnHand() {
        return quantityOnHand;
    }

    public void setQuantityOnHand(Integer quantityOnHand) {
        this.quantityOnHand = quantityOnHand;
    }

    public BigDecimal getMarkup() {
        return markup;
    }

    public void setMarkup(BigDecimal markup) {
        this.markup = markup;
    }

    public String getAvailable() {
        return available;
    }

    public void setAvailable(String available) {
        this.available = available;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Manufacturer getManufacturerId() {
        return manufacturerId;
    }

    public void setManufacturerId(Manufacturer manufacturerId) {
        this.manufacturerId = manufacturerId;
    }

    public ProductCode getProductCode() {
        return productCode;
    }

    public void setProductCode(ProductCode productCode) {
        this.productCode = productCode;
    }

    public Collection<PurchaseOrder> getPurchaseOrderCollection() {
        return purchaseOrderCollection;
    }

    public void setPurchaseOrderCollection(Collection<PurchaseOrder> purchaseOrderCollection) {
        this.purchaseOrderCollection = purchaseOrderCollection;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (productId != null ? productId.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof Product)) {
            return false;
        }
        Product other = (Product) object;
        if ((this.productId == null && other.productId != null) || (this.productId != null && !this.productId.equals(other.productId))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return productId.toString();
    }

}
"
-6011496567103456266,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\entities\ProductCode.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.entities;

import java.io.Serializable;
import java.util.Collection;
import javax.persistence.Basic;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;

/**
 *
 * @author mbohm
 */
@Entity
@Table(name = ""PRODUCT_CODE"")
@NamedQueries({@NamedQuery(name = ""ProductCode.findAll"", query = ""SELECT p FROM ProductCode p""), @NamedQuery(name = ""ProductCode.findByProdCode"", query = ""SELECT p FROM ProductCode p WHERE p.prodCode = :prodCode""), @NamedQuery(name = ""ProductCode.findByDiscountCode"", query = ""SELECT p FROM ProductCode p WHERE p.discountCode = :discountCode""), @NamedQuery(name = ""ProductCode.findByDescription"", query = ""SELECT p FROM ProductCode p WHERE p.description = :description"")})
public class ProductCode implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @Basic(optional = false)
    @Column(name = ""PROD_CODE"")
    private String prodCode;
    @Basic(optional = false)
    @Column(name = ""DISCOUNT_CODE"")
    private char discountCode;
    @Column(name = ""DESCRIPTION"")
    private String description;
    @OneToMany(cascade = CascadeType.ALL, mappedBy = ""productCode"")
    private Collection<Product> productCollection;

    public ProductCode() {
    }

    public ProductCode(String prodCode) {
        this.prodCode = prodCode;
    }

    public ProductCode(String prodCode, char discountCode) {
        this.prodCode = prodCode;
        this.discountCode = discountCode;
    }

    public String getProdCode() {
        return prodCode;
    }

    public void setProdCode(String prodCode) {
        this.prodCode = prodCode;
    }

    public char getDiscountCode() {
        return discountCode;
    }

    public void setDiscountCode(char discountCode) {
        this.discountCode = discountCode;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public Collection<Product> getProductCollection() {
        return productCollection;
    }

    public void setProductCollection(Collection<Product> productCollection) {
        this.productCollection = productCollection;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (prodCode != null ? prodCode.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof ProductCode)) {
            return false;
        }
        ProductCode other = (ProductCode) object;
        if ((this.prodCode == null && other.prodCode != null) || (this.prodCode != null && !this.prodCode.equals(other.prodCode))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return prodCode.toString();
    }

}
"
1031110700799924840,F://JavaWorkspace//JsfJpaCrud\src\java\jpa\entities\PurchaseOrder.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jpa.entities;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.Date;
import javax.persistence.Basic;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;

/**
 *
 * @author mbohm
 */
@Entity
@Table(name = ""PURCHASE_ORDER"")
@NamedQueries({@NamedQuery(name = ""PurchaseOrder.findAll"", query = ""SELECT p FROM PurchaseOrder p""), @NamedQuery(name = ""PurchaseOrder.findByOrderNum"", query = ""SELECT p FROM PurchaseOrder p WHERE p.orderNum = :orderNum""), @NamedQuery(name = ""PurchaseOrder.findByQuantity"", query = ""SELECT p FROM PurchaseOrder p WHERE p.quantity = :quantity""), @NamedQuery(name = ""PurchaseOrder.findByShippingCost"", query = ""SELECT p FROM PurchaseOrder p WHERE p.shippingCost = :shippingCost""), @NamedQuery(name = ""PurchaseOrder.findBySalesDate"", query = ""SELECT p FROM PurchaseOrder p WHERE p.salesDate = :salesDate""), @NamedQuery(name = ""PurchaseOrder.findByShippingDate"", query = ""SELECT p FROM PurchaseOrder p WHERE p.shippingDate = :shippingDate""), @NamedQuery(name = ""PurchaseOrder.findByFreightCompany"", query = ""SELECT p FROM PurchaseOrder p WHERE p.freightCompany = :freightCompany"")})
public class PurchaseOrder implements Serializable {
    private static final long serialVersionUID = 1L;
    @Id
    @Basic(optional = false)
    @Column(name = ""ORDER_NUM"")
    private Integer orderNum;
    @Column(name = ""QUANTITY"")
    private Short quantity;
    @Column(name = ""SHIPPING_COST"")
    private BigDecimal shippingCost;
    @Column(name = ""SALES_DATE"")
    @Temporal(TemporalType.DATE)
    private Date salesDate;
    @Column(name = ""SHIPPING_DATE"")
    @Temporal(TemporalType.DATE)
    private Date shippingDate;
    @Column(name = ""FREIGHT_COMPANY"")
    private String freightCompany;
    @JoinColumn(name = ""CUSTOMER_ID"", referencedColumnName = ""CUSTOMER_ID"")
    @ManyToOne(optional = false)
    private Customer customerId;
    @JoinColumn(name = ""PRODUCT_ID"", referencedColumnName = ""PRODUCT_ID"")
    @ManyToOne(optional = false)
    private Product productId;

    public PurchaseOrder() {
    }

    public PurchaseOrder(Integer orderNum) {
        this.orderNum = orderNum;
    }

    public Integer getOrderNum() {
        return orderNum;
    }

    public void setOrderNum(Integer orderNum) {
        this.orderNum = orderNum;
    }

    public Short getQuantity() {
        return quantity;
    }

    public void setQuantity(Short quantity) {
        this.quantity = quantity;
    }

    public BigDecimal getShippingCost() {
        return shippingCost;
    }

    public void setShippingCost(BigDecimal shippingCost) {
        this.shippingCost = shippingCost;
    }

    public Date getSalesDate() {
        return salesDate;
    }

    public void setSalesDate(Date salesDate) {
        this.salesDate = salesDate;
    }

    public Date getShippingDate() {
        return shippingDate;
    }

    public void setShippingDate(Date shippingDate) {
        this.shippingDate = shippingDate;
    }

    public String getFreightCompany() {
        return freightCompany;
    }

    public void setFreightCompany(String freightCompany) {
        this.freightCompany = freightCompany;
    }

    public Customer getCustomerId() {
        return customerId;
    }

    public void setCustomerId(Customer customerId) {
        this.customerId = customerId;
    }

    public Product getProductId() {
        return productId;
    }

    public void setProductId(Product productId) {
        this.productId = productId;
    }

    @Override
    public int hashCode() {
        int hash = 0;
        hash += (orderNum != null ? orderNum.hashCode() : 0);
        return hash;
    }

    @Override
    public boolean equals(Object object) {
        // TODO: Warning - this method won't work in the case the id fields are not set
        if (!(object instanceof PurchaseOrder)) {
            return false;
        }
        PurchaseOrder other = (PurchaseOrder) object;
        if ((this.orderNum == null && other.orderNum != null) || (this.orderNum != null && !this.orderNum.equals(other.orderNum))) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return ""jpa.entities.PurchaseOrder[orderNum="" + orderNum + ""]"";
    }

}
"
-2448897674413776721,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\CustomerController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;
import jpa.controllers.CustomerJpaController;
import jpa.entities.Customer;
import jsf.util.JsfUtil;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.IllegalOrphanException;
import jsf.util.PagingInfo;

/**
 *
 * @author mbohm
 */
public class CustomerController {

    public CustomerController() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        jpaController = (CustomerJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""customerJpa"");
        pagingInfo = new PagingInfo();
        converter = new CustomerConverter();
    }
    private Customer customer = null;
    private List<Customer> customerItems = null;
    private CustomerJpaController jpaController = null;
    private CustomerConverter converter = null;
    private PagingInfo pagingInfo = null;

    public PagingInfo getPagingInfo() {
        if (pagingInfo.getItemCount() == -1) {
            pagingInfo.setItemCount(jpaController.getCustomerCount());
        }
        return pagingInfo;
    }

    public SelectItem[] getCustomerItemsAvailableSelectMany() {
        return JsfUtil.getSelectItems(jpaController.findCustomerEntities(), false);
    }

    public SelectItem[] getCustomerItemsAvailableSelectOne() {
        return JsfUtil.getSelectItems(jpaController.findCustomerEntities(), true);
    }

    public Customer getCustomer() {
        if (customer == null) {
            customer = (Customer) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentCustomer"", converter, null);
        }
        if (customer == null) {
            customer = new Customer();
        }
        return customer;
    }

    public String listSetup() {
        reset(true);
        return ""customer_list"";
    }

    public String createSetup() {
        reset(false);
        customer = new Customer();
        return ""customer_create"";
    }

    public String create() {
        try {
            jpaController.create(customer);
            JsfUtil.addSuccessMessage(""Customer was successfully created."");
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return listSetup();
    }

    public String detailSetup() {
        return scalarSetup(""customer_detail"");
    }

    public String editSetup() {
        return scalarSetup(""customer_edit"");
    }

    private String scalarSetup(String destination) {
        reset(false);
        customer = (Customer) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentCustomer"", converter, null);
        if (customer == null) {
            String requestCustomerString = JsfUtil.getRequestParameter(""jsfcrud.currentCustomer"");
            JsfUtil.addErrorMessage(""The customer with id "" + requestCustomerString + "" no longer exists."");
            return relatedOrListOutcome();
        }
        return destination;
    }

    public String edit() {
        String customerString = converter.getAsString(FacesContext.getCurrentInstance(), null, customer);
        String currentCustomerString = JsfUtil.getRequestParameter(""jsfcrud.currentCustomer"");
        if (customerString == null || customerString.length() == 0 || !customerString.equals(currentCustomerString)) {
            String outcome = editSetup();
            if (""customer_edit"".equals(outcome)) {
                JsfUtil.addErrorMessage(""Could not edit customer. Try again."");
            }
            return outcome;
        }
        try {
            jpaController.edit(customer);
            JsfUtil.addSuccessMessage(""Customer was successfully updated."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return listSetup();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return detailSetup();
    }

    public String destroy() {
        String idAsString = JsfUtil.getRequestParameter(""jsfcrud.currentCustomer"");
        Integer id = new Integer(idAsString);
        try {
            jpaController.destroy(id);
            JsfUtil.addSuccessMessage(""Customer was successfully deleted."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return relatedOrListOutcome();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return relatedOrListOutcome();
    }

    private String relatedOrListOutcome() {
        String relatedControllerOutcome = relatedControllerOutcome();
        if (relatedControllerOutcome != null) {
            return relatedControllerOutcome;
        }
        return listSetup();
    }

    public List<Customer> getCustomerItems() {
        if (customerItems == null) {
            getPagingInfo();
            customerItems = jpaController.findCustomerEntities(pagingInfo.getBatchSize(), pagingInfo.getFirstItem());
        }
        return customerItems;
    }

    public String next() {
        reset(false);
        getPagingInfo().nextPage();
        return ""customer_list"";
    }

    public String prev() {
        reset(false);
        getPagingInfo().previousPage();
        return ""customer_list"";
    }

    private String relatedControllerOutcome() {
        String relatedControllerString = JsfUtil.getRequestParameter(""jsfcrud.relatedController"");
        String relatedControllerTypeString = JsfUtil.getRequestParameter(""jsfcrud.relatedControllerType"");
        if (relatedControllerString != null && relatedControllerTypeString != null) {
            FacesContext context = FacesContext.getCurrentInstance();
            Object relatedController = context.getApplication().getELResolver().getValue(context.getELContext(), null, relatedControllerString);
            try {
                Class<?> relatedControllerType = Class.forName(relatedControllerTypeString);
                Method detailSetupMethod = relatedControllerType.getMethod(""detailSetup"");
                return (String) detailSetupMethod.invoke(relatedController);
            } catch (ClassNotFoundException e) {
                throw new FacesException(e);
            } catch (NoSuchMethodException e) {
                throw new FacesException(e);
            } catch (IllegalAccessException e) {
                throw new FacesException(e);
            } catch (InvocationTargetException e) {
                throw new FacesException(e);
            }
        }
        return null;
    }

    private void reset(boolean resetFirstItem) {
        customer = null;
        customerItems = null;
        pagingInfo.setItemCount(-1);
        if (resetFirstItem) {
            pagingInfo.setFirstItem(0);
        }
    }

    public void validateCreate(FacesContext facesContext, UIComponent component, Object value) {
        Customer newCustomer = new Customer();
        String newCustomerString = converter.getAsString(FacesContext.getCurrentInstance(), null, newCustomer);
        String customerString = converter.getAsString(FacesContext.getCurrentInstance(), null, customer);
        if (!newCustomerString.equals(customerString)) {
            createSetup();
        }
    }

    public Converter getConverter() {
        return converter;
    }

}
"
-5234961285572948994,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\CustomerConverter.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import jpa.controllers.CustomerJpaController;
import jpa.entities.Customer;

/**
 *
 * @author mbohm
 */
public class CustomerConverter implements Converter {

    public Object getAsObject(FacesContext facesContext, UIComponent component, String string) {
        if (string == null || string.length() == 0) {
            return null;
        }
        Integer id = new Integer(string);
        CustomerJpaController controller = (CustomerJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""customerJpa"");
        return controller.findCustomer(id);
    }

    public String getAsString(FacesContext facesContext, UIComponent component, Object object) {
        if (object == null) {
            return null;
        }
        if (object instanceof Customer) {
            Customer o = (Customer) object;
            return o.getCustomerId() == null ? """" : o.getCustomerId().toString();
        } else {
            throw new IllegalArgumentException(""object "" + object + "" is of type "" + object.getClass().getName() + ""; expected type: jpa.entities.Customer"");
        }
    }

}
"
7021928435170811866,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\DiscountCodeController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;
import jpa.controllers.DiscountCodeJpaController;
import jpa.entities.DiscountCode;
import jsf.util.JsfUtil;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.IllegalOrphanException;
import jsf.util.PagingInfo;

/**
 *
 * @author mbohm
 */
public class DiscountCodeController {

    public DiscountCodeController() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        jpaController = (DiscountCodeJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""discountCodeJpa"");
        pagingInfo = new PagingInfo();
        converter = new DiscountCodeConverter();
    }
    private DiscountCode discountCode = null;
    private List<DiscountCode> discountCodeItems = null;
    private DiscountCodeJpaController jpaController = null;
    private DiscountCodeConverter converter = null;
    private PagingInfo pagingInfo = null;

    public PagingInfo getPagingInfo() {
        if (pagingInfo.getItemCount() == -1) {
            pagingInfo.setItemCount(jpaController.getDiscountCodeCount());
        }
        return pagingInfo;
    }

    public SelectItem[] getDiscountCodeItemsAvailableSelectMany() {
        return JsfUtil.getSelectItems(jpaController.findDiscountCodeEntities(), false);
    }

    public SelectItem[] getDiscountCodeItemsAvailableSelectOne() {
        return JsfUtil.getSelectItems(jpaController.findDiscountCodeEntities(), true);
    }

    public DiscountCode getDiscountCode() {
        if (discountCode == null) {
            discountCode = (DiscountCode) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentDiscountCode"", converter, null);
        }
        if (discountCode == null) {
            discountCode = new DiscountCode();
        }
        return discountCode;
    }

    public String listSetup() {
        reset(true);
        return ""discountCode_list"";
    }

    public String createSetup() {
        reset(false);
        discountCode = new DiscountCode();
        return ""discountCode_create"";
    }

    public String create() {
        try {
            jpaController.create(discountCode);
            JsfUtil.addSuccessMessage(""DiscountCode was successfully created."");
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return listSetup();
    }

    public String detailSetup() {
        return scalarSetup(""discountCode_detail"");
    }

    public String editSetup() {
        return scalarSetup(""discountCode_edit"");
    }

    private String scalarSetup(String destination) {
        reset(false);
        discountCode = (DiscountCode) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentDiscountCode"", converter, null);
        if (discountCode == null) {
            String requestDiscountCodeString = JsfUtil.getRequestParameter(""jsfcrud.currentDiscountCode"");
            JsfUtil.addErrorMessage(""The discountCode with id "" + requestDiscountCodeString + "" no longer exists."");
            return relatedOrListOutcome();
        }
        return destination;
    }

    public String edit() {
        String discountCodeString = converter.getAsString(FacesContext.getCurrentInstance(), null, discountCode);
        String currentDiscountCodeString = JsfUtil.getRequestParameter(""jsfcrud.currentDiscountCode"");
        if (discountCodeString == null || discountCodeString.length() == 0 || !discountCodeString.equals(currentDiscountCodeString)) {
            String outcome = editSetup();
            if (""discountCode_edit"".equals(outcome)) {
                JsfUtil.addErrorMessage(""Could not edit discountCode. Try again."");
            }
            return outcome;
        }
        try {
            jpaController.edit(discountCode);
            JsfUtil.addSuccessMessage(""DiscountCode was successfully updated."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return listSetup();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return detailSetup();
    }

    public String destroy() {
        String idAsString = JsfUtil.getRequestParameter(""jsfcrud.currentDiscountCode"");
        Character id = new Character(idAsString.charAt(0));
        try {
            jpaController.destroy(id);
            JsfUtil.addSuccessMessage(""DiscountCode was successfully deleted."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return relatedOrListOutcome();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return relatedOrListOutcome();
    }

    private String relatedOrListOutcome() {
        String relatedControllerOutcome = relatedControllerOutcome();
        if (relatedControllerOutcome != null) {
            return relatedControllerOutcome;
        }
        return listSetup();
    }

    public List<DiscountCode> getDiscountCodeItems() {
        if (discountCodeItems == null) {
            getPagingInfo();
            discountCodeItems = jpaController.findDiscountCodeEntities(pagingInfo.getBatchSize(), pagingInfo.getFirstItem());
        }
        return discountCodeItems;
    }

    public String next() {
        reset(false);
        getPagingInfo().nextPage();
        return ""discountCode_list"";
    }

    public String prev() {
        reset(false);
        getPagingInfo().previousPage();
        return ""discountCode_list"";
    }

    private String relatedControllerOutcome() {
        String relatedControllerString = JsfUtil.getRequestParameter(""jsfcrud.relatedController"");
        String relatedControllerTypeString = JsfUtil.getRequestParameter(""jsfcrud.relatedControllerType"");
        if (relatedControllerString != null && relatedControllerTypeString != null) {
            FacesContext context = FacesContext.getCurrentInstance();
            Object relatedController = context.getApplication().getELResolver().getValue(context.getELContext(), null, relatedControllerString);
            try {
                Class<?> relatedControllerType = Class.forName(relatedControllerTypeString);
                Method detailSetupMethod = relatedControllerType.getMethod(""detailSetup"");
                return (String) detailSetupMethod.invoke(relatedController);
            } catch (ClassNotFoundException e) {
                throw new FacesException(e);
            } catch (NoSuchMethodException e) {
                throw new FacesException(e);
            } catch (IllegalAccessException e) {
                throw new FacesException(e);
            } catch (InvocationTargetException e) {
                throw new FacesException(e);
            }
        }
        return null;
    }

    private void reset(boolean resetFirstItem) {
        discountCode = null;
        discountCodeItems = null;
        pagingInfo.setItemCount(-1);
        if (resetFirstItem) {
            pagingInfo.setFirstItem(0);
        }
    }

    public void validateCreate(FacesContext facesContext, UIComponent component, Object value) {
        DiscountCode newDiscountCode = new DiscountCode();
        String newDiscountCodeString = converter.getAsString(FacesContext.getCurrentInstance(), null, newDiscountCode);
        String discountCodeString = converter.getAsString(FacesContext.getCurrentInstance(), null, discountCode);
        if (!newDiscountCodeString.equals(discountCodeString)) {
            createSetup();
        }
    }

    public Converter getConverter() {
        return converter;
    }

}
"
2874940695240965541,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\DiscountCodeConverter.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import jpa.controllers.DiscountCodeJpaController;
import jpa.entities.DiscountCode;

/**
 *
 * @author mbohm
 */
public class DiscountCodeConverter implements Converter {

    public Object getAsObject(FacesContext facesContext, UIComponent component, String string) {
        if (string == null || string.length() == 0) {
            return null;
        }
        Character id = new Character(string.charAt(0));
        DiscountCodeJpaController controller = (DiscountCodeJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""discountCodeJpa"");
        return controller.findDiscountCode(id);
    }

    public String getAsString(FacesContext facesContext, UIComponent component, Object object) {
        if (object == null) {
            return null;
        }
        if (object instanceof DiscountCode) {
            DiscountCode o = (DiscountCode) object;
            return o.getDiscountCode() == null ? """" : o.getDiscountCode().toString();
        } else {
            throw new IllegalArgumentException(""object "" + object + "" is of type "" + object.getClass().getName() + ""; expected type: jpa.entities.DiscountCode"");
        }
    }

}
"
-3171550596778790670,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\ManufacturerController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;
import jpa.controllers.ManufacturerJpaController;
import jpa.entities.Manufacturer;
import jsf.util.JsfUtil;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.IllegalOrphanException;
import jsf.util.PagingInfo;

/**
 *
 * @author mbohm
 */
public class ManufacturerController {

    public ManufacturerController() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        jpaController = (ManufacturerJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""manufacturerJpa"");
        pagingInfo = new PagingInfo();
        converter = new ManufacturerConverter();
    }
    private Manufacturer manufacturer = null;
    private List<Manufacturer> manufacturerItems = null;
    private ManufacturerJpaController jpaController = null;
    private ManufacturerConverter converter = null;
    private PagingInfo pagingInfo = null;

    public PagingInfo getPagingInfo() {
        if (pagingInfo.getItemCount() == -1) {
            pagingInfo.setItemCount(jpaController.getManufacturerCount());
        }
        return pagingInfo;
    }

    public SelectItem[] getManufacturerItemsAvailableSelectMany() {
        return JsfUtil.getSelectItems(jpaController.findManufacturerEntities(), false);
    }

    public SelectItem[] getManufacturerItemsAvailableSelectOne() {
        return JsfUtil.getSelectItems(jpaController.findManufacturerEntities(), true);
    }

    public Manufacturer getManufacturer() {
        if (manufacturer == null) {
            manufacturer = (Manufacturer) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentManufacturer"", converter, null);
        }
        if (manufacturer == null) {
            manufacturer = new Manufacturer();
        }
        return manufacturer;
    }

    public String listSetup() {
        reset(true);
        return ""manufacturer_list"";
    }

    public String createSetup() {
        reset(false);
        manufacturer = new Manufacturer();
        return ""manufacturer_create"";
    }

    public String create() {
        try {
            jpaController.create(manufacturer);
            JsfUtil.addSuccessMessage(""Manufacturer was successfully created."");
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return listSetup();
    }

    public String detailSetup() {
        return scalarSetup(""manufacturer_detail"");
    }

    public String editSetup() {
        return scalarSetup(""manufacturer_edit"");
    }

    private String scalarSetup(String destination) {
        reset(false);
        manufacturer = (Manufacturer) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentManufacturer"", converter, null);
        if (manufacturer == null) {
            String requestManufacturerString = JsfUtil.getRequestParameter(""jsfcrud.currentManufacturer"");
            JsfUtil.addErrorMessage(""The manufacturer with id "" + requestManufacturerString + "" no longer exists."");
            return relatedOrListOutcome();
        }
        return destination;
    }

    public String edit() {
        String manufacturerString = converter.getAsString(FacesContext.getCurrentInstance(), null, manufacturer);
        String currentManufacturerString = JsfUtil.getRequestParameter(""jsfcrud.currentManufacturer"");
        if (manufacturerString == null || manufacturerString.length() == 0 || !manufacturerString.equals(currentManufacturerString)) {
            String outcome = editSetup();
            if (""manufacturer_edit"".equals(outcome)) {
                JsfUtil.addErrorMessage(""Could not edit manufacturer. Try again."");
            }
            return outcome;
        }
        try {
            jpaController.edit(manufacturer);
            JsfUtil.addSuccessMessage(""Manufacturer was successfully updated."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return listSetup();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return detailSetup();
    }

    public String destroy() {
        String idAsString = JsfUtil.getRequestParameter(""jsfcrud.currentManufacturer"");
        Integer id = new Integer(idAsString);
        try {
            jpaController.destroy(id);
            JsfUtil.addSuccessMessage(""Manufacturer was successfully deleted."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return relatedOrListOutcome();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return relatedOrListOutcome();
    }

    private String relatedOrListOutcome() {
        String relatedControllerOutcome = relatedControllerOutcome();
        if (relatedControllerOutcome != null) {
            return relatedControllerOutcome;
        }
        return listSetup();
    }

    public List<Manufacturer> getManufacturerItems() {
        if (manufacturerItems == null) {
            getPagingInfo();
            manufacturerItems = jpaController.findManufacturerEntities(pagingInfo.getBatchSize(), pagingInfo.getFirstItem());
        }
        return manufacturerItems;
    }

    public String next() {
        reset(false);
        getPagingInfo().nextPage();
        return ""manufacturer_list"";
    }

    public String prev() {
        reset(false);
        getPagingInfo().previousPage();
        return ""manufacturer_list"";
    }

    private String relatedControllerOutcome() {
        String relatedControllerString = JsfUtil.getRequestParameter(""jsfcrud.relatedController"");
        String relatedControllerTypeString = JsfUtil.getRequestParameter(""jsfcrud.relatedControllerType"");
        if (relatedControllerString != null && relatedControllerTypeString != null) {
            FacesContext context = FacesContext.getCurrentInstance();
            Object relatedController = context.getApplication().getELResolver().getValue(context.getELContext(), null, relatedControllerString);
            try {
                Class<?> relatedControllerType = Class.forName(relatedControllerTypeString);
                Method detailSetupMethod = relatedControllerType.getMethod(""detailSetup"");
                return (String) detailSetupMethod.invoke(relatedController);
            } catch (ClassNotFoundException e) {
                throw new FacesException(e);
            } catch (NoSuchMethodException e) {
                throw new FacesException(e);
            } catch (IllegalAccessException e) {
                throw new FacesException(e);
            } catch (InvocationTargetException e) {
                throw new FacesException(e);
            }
        }
        return null;
    }

    private void reset(boolean resetFirstItem) {
        manufacturer = null;
        manufacturerItems = null;
        pagingInfo.setItemCount(-1);
        if (resetFirstItem) {
            pagingInfo.setFirstItem(0);
        }
    }

    public void validateCreate(FacesContext facesContext, UIComponent component, Object value) {
        Manufacturer newManufacturer = new Manufacturer();
        String newManufacturerString = converter.getAsString(FacesContext.getCurrentInstance(), null, newManufacturer);
        String manufacturerString = converter.getAsString(FacesContext.getCurrentInstance(), null, manufacturer);
        if (!newManufacturerString.equals(manufacturerString)) {
            createSetup();
        }
    }

    public Converter getConverter() {
        return converter;
    }

}
"
2669874623614739248,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\ManufacturerConverter.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import jpa.controllers.ManufacturerJpaController;
import jpa.entities.Manufacturer;

/**
 *
 * @author mbohm
 */
public class ManufacturerConverter implements Converter {

    public Object getAsObject(FacesContext facesContext, UIComponent component, String string) {
        if (string == null || string.length() == 0) {
            return null;
        }
        Integer id = new Integer(string);
        ManufacturerJpaController controller = (ManufacturerJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""manufacturerJpa"");
        return controller.findManufacturer(id);
    }

    public String getAsString(FacesContext facesContext, UIComponent component, Object object) {
        if (object == null) {
            return null;
        }
        if (object instanceof Manufacturer) {
            Manufacturer o = (Manufacturer) object;
            return o.getManufacturerId() == null ? """" : o.getManufacturerId().toString();
        } else {
            throw new IllegalArgumentException(""object "" + object + "" is of type "" + object.getClass().getName() + ""; expected type: jpa.entities.Manufacturer"");
        }
    }

}
"
-5006353195717904254,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\MicroMarketController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;
import jpa.controllers.MicroMarketJpaController;
import jpa.entities.MicroMarket;
import jsf.util.JsfUtil;
import jpa.controllers.exceptions.NonexistentEntityException;
import jsf.util.PagingInfo;

/**
 *
 * @author mbohm
 */
public class MicroMarketController {

    public MicroMarketController() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        jpaController = (MicroMarketJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""microMarketJpa"");
        pagingInfo = new PagingInfo();
        converter = new MicroMarketConverter();
    }
    private MicroMarket microMarket = null;
    private List<MicroMarket> microMarketItems = null;
    private MicroMarketJpaController jpaController = null;
    private MicroMarketConverter converter = null;
    private PagingInfo pagingInfo = null;

    public PagingInfo getPagingInfo() {
        if (pagingInfo.getItemCount() == -1) {
            pagingInfo.setItemCount(jpaController.getMicroMarketCount());
        }
        return pagingInfo;
    }

    public SelectItem[] getMicroMarketItemsAvailableSelectMany() {
        return JsfUtil.getSelectItems(jpaController.findMicroMarketEntities(), false);
    }

    public SelectItem[] getMicroMarketItemsAvailableSelectOne() {
        return JsfUtil.getSelectItems(jpaController.findMicroMarketEntities(), true);
    }

    public MicroMarket getMicroMarket() {
        if (microMarket == null) {
            microMarket = (MicroMarket) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentMicroMarket"", converter, null);
        }
        if (microMarket == null) {
            microMarket = new MicroMarket();
        }
        return microMarket;
    }

    public String listSetup() {
        reset(true);
        return ""microMarket_list"";
    }

    public String createSetup() {
        reset(false);
        microMarket = new MicroMarket();
        return ""microMarket_create"";
    }

    public String create() {
        try {
            jpaController.create(microMarket);
            JsfUtil.addSuccessMessage(""MicroMarket was successfully created."");
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return listSetup();
    }

    public String detailSetup() {
        return scalarSetup(""microMarket_detail"");
    }

    public String editSetup() {
        return scalarSetup(""microMarket_edit"");
    }

    private String scalarSetup(String destination) {
        reset(false);
        microMarket = (MicroMarket) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentMicroMarket"", converter, null);
        if (microMarket == null) {
            String requestMicroMarketString = JsfUtil.getRequestParameter(""jsfcrud.currentMicroMarket"");
            JsfUtil.addErrorMessage(""The microMarket with id "" + requestMicroMarketString + "" no longer exists."");
            return relatedOrListOutcome();
        }
        return destination;
    }

    public String edit() {
        String microMarketString = converter.getAsString(FacesContext.getCurrentInstance(), null, microMarket);
        String currentMicroMarketString = JsfUtil.getRequestParameter(""jsfcrud.currentMicroMarket"");
        if (microMarketString == null || microMarketString.length() == 0 || !microMarketString.equals(currentMicroMarketString)) {
            String outcome = editSetup();
            if (""microMarket_edit"".equals(outcome)) {
                JsfUtil.addErrorMessage(""Could not edit microMarket. Try again."");
            }
            return outcome;
        }
        try {
            jpaController.edit(microMarket);
            JsfUtil.addSuccessMessage(""MicroMarket was successfully updated."");
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return listSetup();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return detailSetup();
    }

    public String destroy() {
        String idAsString = JsfUtil.getRequestParameter(""jsfcrud.currentMicroMarket"");
        String id = idAsString;
        try {
            jpaController.destroy(id);
            JsfUtil.addSuccessMessage(""MicroMarket was successfully deleted."");
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return relatedOrListOutcome();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return relatedOrListOutcome();
    }

    private String relatedOrListOutcome() {
        String relatedControllerOutcome = relatedControllerOutcome();
        if (relatedControllerOutcome != null) {
            return relatedControllerOutcome;
        }
        return listSetup();
    }

    public List<MicroMarket> getMicroMarketItems() {
        if (microMarketItems == null) {
            getPagingInfo();
            microMarketItems = jpaController.findMicroMarketEntities(pagingInfo.getBatchSize(), pagingInfo.getFirstItem());
        }
        return microMarketItems;
    }

    public String next() {
        reset(false);
        getPagingInfo().nextPage();
        return ""microMarket_list"";
    }

    public String prev() {
        reset(false);
        getPagingInfo().previousPage();
        return ""microMarket_list"";
    }

    private String relatedControllerOutcome() {
        String relatedControllerString = JsfUtil.getRequestParameter(""jsfcrud.relatedController"");
        String relatedControllerTypeString = JsfUtil.getRequestParameter(""jsfcrud.relatedControllerType"");
        if (relatedControllerString != null && relatedControllerTypeString != null) {
            FacesContext context = FacesContext.getCurrentInstance();
            Object relatedController = context.getApplication().getELResolver().getValue(context.getELContext(), null, relatedControllerString);
            try {
                Class<?> relatedControllerType = Class.forName(relatedControllerTypeString);
                Method detailSetupMethod = relatedControllerType.getMethod(""detailSetup"");
                return (String) detailSetupMethod.invoke(relatedController);
            } catch (ClassNotFoundException e) {
                throw new FacesException(e);
            } catch (NoSuchMethodException e) {
                throw new FacesException(e);
            } catch (IllegalAccessException e) {
                throw new FacesException(e);
            } catch (InvocationTargetException e) {
                throw new FacesException(e);
            }
        }
        return null;
    }

    private void reset(boolean resetFirstItem) {
        microMarket = null;
        microMarketItems = null;
        pagingInfo.setItemCount(-1);
        if (resetFirstItem) {
            pagingInfo.setFirstItem(0);
        }
    }

    public void validateCreate(FacesContext facesContext, UIComponent component, Object value) {
        MicroMarket newMicroMarket = new MicroMarket();
        String newMicroMarketString = converter.getAsString(FacesContext.getCurrentInstance(), null, newMicroMarket);
        String microMarketString = converter.getAsString(FacesContext.getCurrentInstance(), null, microMarket);
        if (!newMicroMarketString.equals(microMarketString)) {
            createSetup();
        }
    }

    public Converter getConverter() {
        return converter;
    }

}
"
7480284301327063933,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\MicroMarketConverter.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import jpa.controllers.MicroMarketJpaController;
import jpa.entities.MicroMarket;

/**
 *
 * @author mbohm
 */
public class MicroMarketConverter implements Converter {

    public Object getAsObject(FacesContext facesContext, UIComponent component, String string) {
        if (string == null || string.length() == 0) {
            return null;
        }
        String id = string;
        MicroMarketJpaController controller = (MicroMarketJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""microMarketJpa"");
        return controller.findMicroMarket(id);
    }

    public String getAsString(FacesContext facesContext, UIComponent component, Object object) {
        if (object == null) {
            return null;
        }
        if (object instanceof MicroMarket) {
            MicroMarket o = (MicroMarket) object;
            return o.getZipCode() == null ? """" : o.getZipCode().toString();
        } else {
            throw new IllegalArgumentException(""object "" + object + "" is of type "" + object.getClass().getName() + ""; expected type: jpa.entities.MicroMarket"");
        }
    }

}
"
-6403069657768016836,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\ProductCodeController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;
import jpa.controllers.ProductCodeJpaController;
import jpa.entities.ProductCode;
import jsf.util.JsfUtil;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.IllegalOrphanException;
import jsf.util.PagingInfo;

/**
 *
 * @author mbohm
 */
public class ProductCodeController {

    public ProductCodeController() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        jpaController = (ProductCodeJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""productCodeJpa"");
        pagingInfo = new PagingInfo();
        converter = new ProductCodeConverter();
    }
    private ProductCode productCode = null;
    private List<ProductCode> productCodeItems = null;
    private ProductCodeJpaController jpaController = null;
    private ProductCodeConverter converter = null;
    private PagingInfo pagingInfo = null;

    public PagingInfo getPagingInfo() {
        if (pagingInfo.getItemCount() == -1) {
            pagingInfo.setItemCount(jpaController.getProductCodeCount());
        }
        return pagingInfo;
    }

    public SelectItem[] getProductCodeItemsAvailableSelectMany() {
        return JsfUtil.getSelectItems(jpaController.findProductCodeEntities(), false);
    }

    public SelectItem[] getProductCodeItemsAvailableSelectOne() {
        return JsfUtil.getSelectItems(jpaController.findProductCodeEntities(), true);
    }

    public ProductCode getProductCode() {
        if (productCode == null) {
            productCode = (ProductCode) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentProductCode"", converter, null);
        }
        if (productCode == null) {
            productCode = new ProductCode();
        }
        return productCode;
    }

    public String listSetup() {
        reset(true);
        return ""productCode_list"";
    }

    public String createSetup() {
        reset(false);
        productCode = new ProductCode();
        return ""productCode_create"";
    }

    public String create() {
        try {
            jpaController.create(productCode);
            JsfUtil.addSuccessMessage(""ProductCode was successfully created."");
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return listSetup();
    }

    public String detailSetup() {
        return scalarSetup(""productCode_detail"");
    }

    public String editSetup() {
        return scalarSetup(""productCode_edit"");
    }

    private String scalarSetup(String destination) {
        reset(false);
        productCode = (ProductCode) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentProductCode"", converter, null);
        if (productCode == null) {
            String requestProductCodeString = JsfUtil.getRequestParameter(""jsfcrud.currentProductCode"");
            JsfUtil.addErrorMessage(""The productCode with id "" + requestProductCodeString + "" no longer exists."");
            return relatedOrListOutcome();
        }
        return destination;
    }

    public String edit() {
        String productCodeString = converter.getAsString(FacesContext.getCurrentInstance(), null, productCode);
        String currentProductCodeString = JsfUtil.getRequestParameter(""jsfcrud.currentProductCode"");
        if (productCodeString == null || productCodeString.length() == 0 || !productCodeString.equals(currentProductCodeString)) {
            String outcome = editSetup();
            if (""productCode_edit"".equals(outcome)) {
                JsfUtil.addErrorMessage(""Could not edit productCode. Try again."");
            }
            return outcome;
        }
        try {
            jpaController.edit(productCode);
            JsfUtil.addSuccessMessage(""ProductCode was successfully updated."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return listSetup();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return detailSetup();
    }

    public String destroy() {
        String idAsString = JsfUtil.getRequestParameter(""jsfcrud.currentProductCode"");
        String id = idAsString;
        try {
            jpaController.destroy(id);
            JsfUtil.addSuccessMessage(""ProductCode was successfully deleted."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return relatedOrListOutcome();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return relatedOrListOutcome();
    }

    private String relatedOrListOutcome() {
        String relatedControllerOutcome = relatedControllerOutcome();
        if (relatedControllerOutcome != null) {
            return relatedControllerOutcome;
        }
        return listSetup();
    }

    public List<ProductCode> getProductCodeItems() {
        if (productCodeItems == null) {
            getPagingInfo();
            productCodeItems = jpaController.findProductCodeEntities(pagingInfo.getBatchSize(), pagingInfo.getFirstItem());
        }
        return productCodeItems;
    }

    public String next() {
        reset(false);
        getPagingInfo().nextPage();
        return ""productCode_list"";
    }

    public String prev() {
        reset(false);
        getPagingInfo().previousPage();
        return ""productCode_list"";
    }

    private String relatedControllerOutcome() {
        String relatedControllerString = JsfUtil.getRequestParameter(""jsfcrud.relatedController"");
        String relatedControllerTypeString = JsfUtil.getRequestParameter(""jsfcrud.relatedControllerType"");
        if (relatedControllerString != null && relatedControllerTypeString != null) {
            FacesContext context = FacesContext.getCurrentInstance();
            Object relatedController = context.getApplication().getELResolver().getValue(context.getELContext(), null, relatedControllerString);
            try {
                Class<?> relatedControllerType = Class.forName(relatedControllerTypeString);
                Method detailSetupMethod = relatedControllerType.getMethod(""detailSetup"");
                return (String) detailSetupMethod.invoke(relatedController);
            } catch (ClassNotFoundException e) {
                throw new FacesException(e);
            } catch (NoSuchMethodException e) {
                throw new FacesException(e);
            } catch (IllegalAccessException e) {
                throw new FacesException(e);
            } catch (InvocationTargetException e) {
                throw new FacesException(e);
            }
        }
        return null;
    }

    private void reset(boolean resetFirstItem) {
        productCode = null;
        productCodeItems = null;
        pagingInfo.setItemCount(-1);
        if (resetFirstItem) {
            pagingInfo.setFirstItem(0);
        }
    }

    public void validateCreate(FacesContext facesContext, UIComponent component, Object value) {
        ProductCode newProductCode = new ProductCode();
        String newProductCodeString = converter.getAsString(FacesContext.getCurrentInstance(), null, newProductCode);
        String productCodeString = converter.getAsString(FacesContext.getCurrentInstance(), null, productCode);
        if (!newProductCodeString.equals(productCodeString)) {
            createSetup();
        }
    }

    public Converter getConverter() {
        return converter;
    }

}
"
4445530031116951921,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\ProductCodeConverter.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import jpa.controllers.ProductCodeJpaController;
import jpa.entities.ProductCode;

/**
 *
 * @author mbohm
 */
public class ProductCodeConverter implements Converter {

    public Object getAsObject(FacesContext facesContext, UIComponent component, String string) {
        if (string == null || string.length() == 0) {
            return null;
        }
        String id = string;
        ProductCodeJpaController controller = (ProductCodeJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""productCodeJpa"");
        return controller.findProductCode(id);
    }

    public String getAsString(FacesContext facesContext, UIComponent component, Object object) {
        if (object == null) {
            return null;
        }
        if (object instanceof ProductCode) {
            ProductCode o = (ProductCode) object;
            return o.getProdCode() == null ? """" : o.getProdCode().toString();
        } else {
            throw new IllegalArgumentException(""object "" + object + "" is of type "" + object.getClass().getName() + ""; expected type: jpa.entities.ProductCode"");
        }
    }

}
"
-3474660028548539954,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\ProductController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;
import jpa.controllers.ProductJpaController;
import jpa.entities.Product;
import jsf.util.JsfUtil;
import jpa.controllers.exceptions.NonexistentEntityException;
import jpa.controllers.exceptions.IllegalOrphanException;
import jsf.util.PagingInfo;

/**
 *
 * @author mbohm
 */
public class ProductController {

    public ProductController() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        jpaController = (ProductJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""productJpa"");
        pagingInfo = new PagingInfo();
        converter = new ProductConverter();
    }
    private Product product = null;
    private List<Product> productItems = null;
    private ProductJpaController jpaController = null;
    private ProductConverter converter = null;
    private PagingInfo pagingInfo = null;

    public PagingInfo getPagingInfo() {
        if (pagingInfo.getItemCount() == -1) {
            pagingInfo.setItemCount(jpaController.getProductCount());
        }
        return pagingInfo;
    }

    public SelectItem[] getProductItemsAvailableSelectMany() {
        return JsfUtil.getSelectItems(jpaController.findProductEntities(), false);
    }

    public SelectItem[] getProductItemsAvailableSelectOne() {
        return JsfUtil.getSelectItems(jpaController.findProductEntities(), true);
    }

    public Product getProduct() {
        if (product == null) {
            product = (Product) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentProduct"", converter, null);
        }
        if (product == null) {
            product = new Product();
        }
        return product;
    }

    public String listSetup() {
        reset(true);
        return ""product_list"";
    }

    public String createSetup() {
        reset(false);
        product = new Product();
        return ""product_create"";
    }

    public String create() {
        try {
            jpaController.create(product);
            JsfUtil.addSuccessMessage(""Product was successfully created."");
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return listSetup();
    }

    public String detailSetup() {
        return scalarSetup(""product_detail"");
    }

    public String editSetup() {
        return scalarSetup(""product_edit"");
    }

    private String scalarSetup(String destination) {
        reset(false);
        product = (Product) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentProduct"", converter, null);
        if (product == null) {
            String requestProductString = JsfUtil.getRequestParameter(""jsfcrud.currentProduct"");
            JsfUtil.addErrorMessage(""The product with id "" + requestProductString + "" no longer exists."");
            return relatedOrListOutcome();
        }
        return destination;
    }

    public String edit() {
        String productString = converter.getAsString(FacesContext.getCurrentInstance(), null, product);
        String currentProductString = JsfUtil.getRequestParameter(""jsfcrud.currentProduct"");
        if (productString == null || productString.length() == 0 || !productString.equals(currentProductString)) {
            String outcome = editSetup();
            if (""product_edit"".equals(outcome)) {
                JsfUtil.addErrorMessage(""Could not edit product. Try again."");
            }
            return outcome;
        }
        try {
            jpaController.edit(product);
            JsfUtil.addSuccessMessage(""Product was successfully updated."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return listSetup();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return detailSetup();
    }

    public String destroy() {
        String idAsString = JsfUtil.getRequestParameter(""jsfcrud.currentProduct"");
        Integer id = new Integer(idAsString);
        try {
            jpaController.destroy(id);
            JsfUtil.addSuccessMessage(""Product was successfully deleted."");
        } catch (IllegalOrphanException oe) {
            JsfUtil.addErrorMessages(oe.getMessages());
            return null;
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return relatedOrListOutcome();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return relatedOrListOutcome();
    }

    private String relatedOrListOutcome() {
        String relatedControllerOutcome = relatedControllerOutcome();
        if (relatedControllerOutcome != null) {
            return relatedControllerOutcome;
        }
        return listSetup();
    }

    public List<Product> getProductItems() {
        if (productItems == null) {
            getPagingInfo();
            productItems = jpaController.findProductEntities(pagingInfo.getBatchSize(), pagingInfo.getFirstItem());
        }
        return productItems;
    }

    public String next() {
        reset(false);
        getPagingInfo().nextPage();
        return ""product_list"";
    }

    public String prev() {
        reset(false);
        getPagingInfo().previousPage();
        return ""product_list"";
    }

    private String relatedControllerOutcome() {
        String relatedControllerString = JsfUtil.getRequestParameter(""jsfcrud.relatedController"");
        String relatedControllerTypeString = JsfUtil.getRequestParameter(""jsfcrud.relatedControllerType"");
        if (relatedControllerString != null && relatedControllerTypeString != null) {
            FacesContext context = FacesContext.getCurrentInstance();
            Object relatedController = context.getApplication().getELResolver().getValue(context.getELContext(), null, relatedControllerString);
            try {
                Class<?> relatedControllerType = Class.forName(relatedControllerTypeString);
                Method detailSetupMethod = relatedControllerType.getMethod(""detailSetup"");
                return (String) detailSetupMethod.invoke(relatedController);
            } catch (ClassNotFoundException e) {
                throw new FacesException(e);
            } catch (NoSuchMethodException e) {
                throw new FacesException(e);
            } catch (IllegalAccessException e) {
                throw new FacesException(e);
            } catch (InvocationTargetException e) {
                throw new FacesException(e);
            }
        }
        return null;
    }

    private void reset(boolean resetFirstItem) {
        product = null;
        productItems = null;
        pagingInfo.setItemCount(-1);
        if (resetFirstItem) {
            pagingInfo.setFirstItem(0);
        }
    }

    public void validateCreate(FacesContext facesContext, UIComponent component, Object value) {
        Product newProduct = new Product();
        String newProductString = converter.getAsString(FacesContext.getCurrentInstance(), null, newProduct);
        String productString = converter.getAsString(FacesContext.getCurrentInstance(), null, product);
        if (!newProductString.equals(productString)) {
            createSetup();
        }
    }

    public Converter getConverter() {
        return converter;
    }

}
"
-4313392635203216340,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\ProductConverter.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import jpa.controllers.ProductJpaController;
import jpa.entities.Product;

/**
 *
 * @author mbohm
 */
public class ProductConverter implements Converter {

    public Object getAsObject(FacesContext facesContext, UIComponent component, String string) {
        if (string == null || string.length() == 0) {
            return null;
        }
        Integer id = new Integer(string);
        ProductJpaController controller = (ProductJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""productJpa"");
        return controller.findProduct(id);
    }

    public String getAsString(FacesContext facesContext, UIComponent component, Object object) {
        if (object == null) {
            return null;
        }
        if (object instanceof Product) {
            Product o = (Product) object;
            return o.getProductId() == null ? """" : o.getProductId().toString();
        } else {
            throw new IllegalArgumentException(""object "" + object + "" is of type "" + object.getClass().getName() + ""; expected type: jpa.entities.Product"");
        }
    }

}
"
7292462145459450869,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\PurchaseOrderController.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import javax.faces.FacesException;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;
import jpa.controllers.PurchaseOrderJpaController;
import jpa.entities.PurchaseOrder;
import jsf.util.JsfUtil;
import jpa.controllers.exceptions.NonexistentEntityException;
import jsf.util.PagingInfo;

/**
 *
 * @author mbohm
 */
public class PurchaseOrderController {

    public PurchaseOrderController() {
        FacesContext facesContext = FacesContext.getCurrentInstance();
        jpaController = (PurchaseOrderJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""purchaseOrderJpa"");
        pagingInfo = new PagingInfo();
        converter = new PurchaseOrderConverter();
    }
    private PurchaseOrder purchaseOrder = null;
    private List<PurchaseOrder> purchaseOrderItems = null;
    private PurchaseOrderJpaController jpaController = null;
    private PurchaseOrderConverter converter = null;
    private PagingInfo pagingInfo = null;

    public PagingInfo getPagingInfo() {
        if (pagingInfo.getItemCount() == -1) {
            pagingInfo.setItemCount(jpaController.getPurchaseOrderCount());
        }
        return pagingInfo;
    }

    public SelectItem[] getPurchaseOrderItemsAvailableSelectMany() {
        return JsfUtil.getSelectItems(jpaController.findPurchaseOrderEntities(), false);
    }

    public SelectItem[] getPurchaseOrderItemsAvailableSelectOne() {
        return JsfUtil.getSelectItems(jpaController.findPurchaseOrderEntities(), true);
    }

    public PurchaseOrder getPurchaseOrder() {
        if (purchaseOrder == null) {
            purchaseOrder = (PurchaseOrder) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentPurchaseOrder"", converter, null);
        }
        if (purchaseOrder == null) {
            purchaseOrder = new PurchaseOrder();
        }
        return purchaseOrder;
    }

    public String listSetup() {
        reset(true);
        return ""purchaseOrder_list"";
    }

    public String createSetup() {
        reset(false);
        purchaseOrder = new PurchaseOrder();
        return ""purchaseOrder_create"";
    }

    public String create() {
        try {
            jpaController.create(purchaseOrder);
            JsfUtil.addSuccessMessage(""PurchaseOrder was successfully created."");
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return listSetup();
    }

    public String detailSetup() {
        return scalarSetup(""purchaseOrder_detail"");
    }

    public String editSetup() {
        return scalarSetup(""purchaseOrder_edit"");
    }

    private String scalarSetup(String destination) {
        reset(false);
        purchaseOrder = (PurchaseOrder) JsfUtil.getObjectFromRequestParameter(""jsfcrud.currentPurchaseOrder"", converter, null);
        if (purchaseOrder == null) {
            String requestPurchaseOrderString = JsfUtil.getRequestParameter(""jsfcrud.currentPurchaseOrder"");
            JsfUtil.addErrorMessage(""The purchaseOrder with id "" + requestPurchaseOrderString + "" no longer exists."");
            return relatedOrListOutcome();
        }
        return destination;
    }

    public String edit() {
        String purchaseOrderString = converter.getAsString(FacesContext.getCurrentInstance(), null, purchaseOrder);
        String currentPurchaseOrderString = JsfUtil.getRequestParameter(""jsfcrud.currentPurchaseOrder"");
        if (purchaseOrderString == null || purchaseOrderString.length() == 0 || !purchaseOrderString.equals(currentPurchaseOrderString)) {
            String outcome = editSetup();
            if (""purchaseOrder_edit"".equals(outcome)) {
                JsfUtil.addErrorMessage(""Could not edit purchaseOrder. Try again."");
            }
            return outcome;
        }
        try {
            jpaController.edit(purchaseOrder);
            JsfUtil.addSuccessMessage(""PurchaseOrder was successfully updated."");
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return listSetup();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return detailSetup();
    }

    public String destroy() {
        String idAsString = JsfUtil.getRequestParameter(""jsfcrud.currentPurchaseOrder"");
        Integer id = new Integer(idAsString);
        try {
            jpaController.destroy(id);
            JsfUtil.addSuccessMessage(""PurchaseOrder was successfully deleted."");
        } catch (NonexistentEntityException ne) {
            JsfUtil.addErrorMessage(ne.getLocalizedMessage());
            return relatedOrListOutcome();
        } catch (Exception e) {
            JsfUtil.ensureAddErrorMessage(e, ""A persistence error occurred."");
            return null;
        }
        return relatedOrListOutcome();
    }

    private String relatedOrListOutcome() {
        String relatedControllerOutcome = relatedControllerOutcome();
        if (relatedControllerOutcome != null) {
            return relatedControllerOutcome;
        }
        return listSetup();
    }

    public List<PurchaseOrder> getPurchaseOrderItems() {
        if (purchaseOrderItems == null) {
            getPagingInfo();
            purchaseOrderItems = jpaController.findPurchaseOrderEntities(pagingInfo.getBatchSize(), pagingInfo.getFirstItem());
        }
        return purchaseOrderItems;
    }

    public String next() {
        reset(false);
        getPagingInfo().nextPage();
        return ""purchaseOrder_list"";
    }

    public String prev() {
        reset(false);
        getPagingInfo().previousPage();
        return ""purchaseOrder_list"";
    }

    private String relatedControllerOutcome() {
        String relatedControllerString = JsfUtil.getRequestParameter(""jsfcrud.relatedController"");
        String relatedControllerTypeString = JsfUtil.getRequestParameter(""jsfcrud.relatedControllerType"");
        if (relatedControllerString != null && relatedControllerTypeString != null) {
            FacesContext context = FacesContext.getCurrentInstance();
            Object relatedController = context.getApplication().getELResolver().getValue(context.getELContext(), null, relatedControllerString);
            try {
                Class<?> relatedControllerType = Class.forName(relatedControllerTypeString);
                Method detailSetupMethod = relatedControllerType.getMethod(""detailSetup"");
                return (String) detailSetupMethod.invoke(relatedController);
            } catch (ClassNotFoundException e) {
                throw new FacesException(e);
            } catch (NoSuchMethodException e) {
                throw new FacesException(e);
            } catch (IllegalAccessException e) {
                throw new FacesException(e);
            } catch (InvocationTargetException e) {
                throw new FacesException(e);
            }
        }
        return null;
    }

    private void reset(boolean resetFirstItem) {
        purchaseOrder = null;
        purchaseOrderItems = null;
        pagingInfo.setItemCount(-1);
        if (resetFirstItem) {
            pagingInfo.setFirstItem(0);
        }
    }

    public void validateCreate(FacesContext facesContext, UIComponent component, Object value) {
        PurchaseOrder newPurchaseOrder = new PurchaseOrder();
        String newPurchaseOrderString = converter.getAsString(FacesContext.getCurrentInstance(), null, newPurchaseOrder);
        String purchaseOrderString = converter.getAsString(FacesContext.getCurrentInstance(), null, purchaseOrder);
        if (!newPurchaseOrderString.equals(purchaseOrderString)) {
            createSetup();
        }
    }

    public Converter getConverter() {
        return converter;
    }

}
"
-3188770688315454024,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\PurchaseOrderConverter.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

package jsf;

import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import jpa.controllers.PurchaseOrderJpaController;
import jpa.entities.PurchaseOrder;

/**
 *
 * @author mbohm
 */
public class PurchaseOrderConverter implements Converter {

    public Object getAsObject(FacesContext facesContext, UIComponent component, String string) {
        if (string == null || string.length() == 0) {
            return null;
        }
        Integer id = new Integer(string);
        PurchaseOrderJpaController controller = (PurchaseOrderJpaController) facesContext.getApplication().getELResolver().getValue(facesContext.getELContext(), null, ""purchaseOrderJpa"");
        return controller.findPurchaseOrder(id);
    }

    public String getAsString(FacesContext facesContext, UIComponent component, Object object) {
        if (object == null) {
            return null;
        }
        if (object instanceof PurchaseOrder) {
            PurchaseOrder o = (PurchaseOrder) object;
            return o.getOrderNum() == null ? """" : o.getOrderNum().toString();
        } else {
            throw new IllegalArgumentException(""object "" + object + "" is of type "" + object.getClass().getName() + ""; expected type: jpa.entities.PurchaseOrder"");
        }
    }

}
"
9064892789968433556,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\util\JsfCrudELResolver.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jsf.util;

import java.beans.BeanInfo;
import java.beans.FeatureDescriptor;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.el.ELContext;
import javax.el.ELException;
import javax.el.ELResolver;

/**
 *
 * @author mbohm
 */
public class JsfCrudELResolver extends ELResolver {
    public static final String JSFCRUD_CLASS = ""jsfcrud_class"";
    public static final String JSFCRUD_METHOD = ""jsfcrud_method"";
    public static final String JSFCRUD_PARAMS = ""jsfcrud_params"";
    public static final String JSFCRUD_INVOKE = ""jsfcrud_invoke"";
    public static final String JSFCRUD_TRANSFORM = ""jsfcrud_transform"";
    public static final String JSFCRUD_NULL = ""jsfcrud_null"";
    
    /**
     * {@inheritDoc}
     */
    public Object getValue(ELContext context, Object base, Object property) {
        if(context == null) {
            throw new NullPointerException();
        }
        
        String propertyName = null;
        if (property != null) {
            propertyName = property.toString();
        }
        
        if (JSFCRUD_NULL.equals(propertyName) &&
                ! (base instanceof JsfCrudMethod) &&
                ! (base instanceof JsfCrudParameterizedMethod) &&
                ! (base instanceof JsfCrudTransform) ) {
            throw new ELException(JSFCRUD_NULL + "" expects a base of type JsfCrudMethod, JsfCrudParameterizedMethod, or JsfCrudTransform; received "" + base);
        }
        
        Object result = null;
        
        if (JSFCRUD_CLASS.equals(propertyName)) {
            if (base != null) {
                throw new ELException(JSFCRUD_CLASS + "" expects a null base; received "" + base);
            }
            result = new JsfCrudClass();
            context.setPropertyResolved(true);
            return result;
        } else if (JSFCRUD_METHOD.equals(propertyName)) {
            if (base == null) {
                throw new ELException(JSFCRUD_METHOD + "" expects a non-null (possibly JsfCrudClass) base; received null"");
            }
            result = new JsfCrudMethod(base);
            context.setPropertyResolved(true);
            return result;
        } else if (JSFCRUD_PARAMS.equals(propertyName)) {
            if (! (base instanceof JsfCrudMethod)) {
                throw new ELException(JSFCRUD_PARAMS + "" expects a base of type JsfCrudMethod; received "" + base);
            }
            result = new JsfCrudParameterizedMethod((JsfCrudMethod)base);
            context.setPropertyResolved(true);
            return result;
        } else if (JSFCRUD_INVOKE.equals(propertyName)) {
            JsfCrudParameterizedMethod parameterizedMethod = getParameterizedMethodToInvoke(base);
            result = parameterizedMethod.invoke();
            context.setPropertyResolved(true);
            return result;
        } else if (JSFCRUD_TRANSFORM.equals(propertyName)) {
            if (base == null) {
                throw new ELException(JSFCRUD_TRANSFORM + "" expects a non-null base; received null"");
            }
            result = new JsfCrudTransform(base);
            context.setPropertyResolved(true);
            return result;
        } else if (base instanceof JsfCrudClass) {
            ((JsfCrudClass)base).setType(propertyName);
            result = base;
            context.setPropertyResolved(true);
            return result;
        } else if (base instanceof JsfCrudMethod) {
            JsfCrudMethod baseAsMethod = (JsfCrudMethod)base;
            if (baseAsMethod.getMethodName() == null) {
                baseAsMethod.setMethodName(propertyName);
                result = base;
                context.setPropertyResolved(true);
                return result;
            }
            else {
                //already have a method name. start adding parameters.
                JsfCrudParameterizedMethod pMethod = new JsfCrudParameterizedMethod(baseAsMethod);
                pMethod.addParameter(property);
                result = pMethod;
                context.setPropertyResolved(true);
                return result;
            }
        } else if (base instanceof JsfCrudParameterizedMethod) {
            ((JsfCrudParameterizedMethod)base).addParameter(property);
            result = base;
            context.setPropertyResolved(true);
            return result;
        } else if (base instanceof JsfCrudTransform) {
            if (JSFCRUD_NULL.equals(propertyName)) {
                ((JsfCrudTransform)base).addNullMethod();
                result = base;
                context.setPropertyResolved(true);
                return result;
            } else if (property instanceof JsfCrudMethod) {
                ((JsfCrudTransform)base).addMethod((JsfCrudMethod)property);
                result = base;
                context.setPropertyResolved(true);
                return result;
            }
            else {
                result = ((JsfCrudTransform)base).getProperty(propertyName);
                context.setPropertyResolved(true);
                return result;
            }
        } 
        
        return null;
    }
    
    private JsfCrudParameterizedMethod getParameterizedMethodToInvoke(Object base) {
        JsfCrudParameterizedMethod parameterizedMethod = null;
        if (base instanceof JsfCrudParameterizedMethod) {
            parameterizedMethod = (JsfCrudParameterizedMethod)base;
        } else if (base instanceof JsfCrudMethod) {
            parameterizedMethod = new JsfCrudParameterizedMethod((JsfCrudMethod)base);
        }
        if (parameterizedMethod == null) {
            throw new ELException(JSFCRUD_INVOKE + "" expects a base of type JsfCrudParameterizedMethod or JsfCrudMethod; received "" + base);
        }
        return parameterizedMethod;
    }
    
    /**
     * {@inheritDoc}
     */
    public void setValue(ELContext context, Object base, Object property, Object value) {
        if(context == null) {
            throw new NullPointerException();
        }
        
        String propertyName = null;
        if (property != null) {
            propertyName = property.toString();
        }

        if ( base instanceof JsfCrudClass || 
             base instanceof JsfCrudMethod ||
             base instanceof JsfCrudParameterizedMethod ||
             (base instanceof JsfCrudTransform && property instanceof JsfCrudMethod) ||
             JSFCRUD_CLASS.equals(propertyName) ||
             JSFCRUD_METHOD.equals(propertyName) ||
             JSFCRUD_PARAMS.equals(propertyName) ||
             JSFCRUD_INVOKE.equals(propertyName) ||
             JSFCRUD_TRANSFORM.equals(propertyName) ||
             JSFCRUD_NULL.equals(propertyName) ||
             property == null ) {
            throw new ELException(""setValue was called with base "" + base + "", property "" + property + "", and value "" + value + ""; expected a base of type JsfCrudTransform and a valid property of the JsfCrudTransform's own base"");
        }
        
        if (base instanceof JsfCrudTransform) {
            ((JsfCrudTransform)base).setProperty(propertyName, value);
            context.setPropertyResolved(true);
        }
    }
    
   /**
     * {@inheritDoc}
     */
    public boolean isReadOnly(ELContext context, Object base, Object property) {
        if(context == null) {
            throw new NullPointerException();
        }
        
        String propertyName = null;
        if (property != null) {
            propertyName = property.toString();
        }

        if (JSFCRUD_CLASS.equals(propertyName) && base == null) {
            context.setPropertyResolved(true);
        } else if (JSFCRUD_METHOD.equals(propertyName) && base != null) {
            context.setPropertyResolved(true);
        } else if (JSFCRUD_PARAMS.equals(propertyName) && (base instanceof JsfCrudMethod)) {
            context.setPropertyResolved(true);
        } else if (JSFCRUD_INVOKE.equals(propertyName) && (base instanceof JsfCrudParameterizedMethod || base instanceof JsfCrudMethod)) {
            context.setPropertyResolved(true);
        } else if (JSFCRUD_TRANSFORM.equals(propertyName) && base != null) {
            context.setPropertyResolved(true);
        } else if (base instanceof JsfCrudClass) {
            context.setPropertyResolved(true);
        } else if (base instanceof JsfCrudMethod) {
            context.setPropertyResolved(true);
        } else if (base instanceof JsfCrudParameterizedMethod) {
            context.setPropertyResolved(true);
        } else if (base instanceof JsfCrudTransform) {
            if (property instanceof JsfCrudMethod) {
                context.setPropertyResolved(true);
            }
            else {
                context.setPropertyResolved(true);
                return false;
            }
        } else {
            return false;
        }
        
        return true;
    }
    
        /**
     * {@inheritDoc}
     */
    public Class<?> getType(ELContext context, Object base, Object property) {
        if(context == null) {
            throw new NullPointerException();
        }
        
        String propertyName = null;
        if (property != null) {
            propertyName = property.toString();
        }

        if (JSFCRUD_CLASS.equals(propertyName) && base == null) {
            context.setPropertyResolved(true);
            return JsfCrudClass.class;
        } else if (JSFCRUD_METHOD.equals(propertyName) && base != null) {
            context.setPropertyResolved(true);
            return JsfCrudMethod.class;
        } else if (JSFCRUD_PARAMS.equals(propertyName) && (base instanceof JsfCrudMethod)) {
            context.setPropertyResolved(true);
            return JsfCrudParameterizedMethod.class;
        } else if (JSFCRUD_INVOKE.equals(propertyName) && (base instanceof JsfCrudParameterizedMethod || base instanceof JsfCrudMethod)) {
            JsfCrudParameterizedMethod parameterizedMethod = getParameterizedMethodToInvoke(base);
            Class<?> result = parameterizedMethod.getReturnType();
            context.setPropertyResolved(true);
            return result;
        } else if (JSFCRUD_TRANSFORM.equals(propertyName) && base != null) {
            context.setPropertyResolved(true);
            return JsfCrudTransform.class;
        } else if (base instanceof JsfCrudClass) {
            context.setPropertyResolved(true);
            return JsfCrudClass.class;
        } else if (base instanceof JsfCrudMethod) {
            JsfCrudMethod baseAsMethod = (JsfCrudMethod)base;
            if (baseAsMethod.getMethodName() == null) {
                context.setPropertyResolved(true);
                return JsfCrudMethod.class;
            }
            else {
                context.setPropertyResolved(true);
                return JsfCrudParameterizedMethod.class;
            }
        } else if (base instanceof JsfCrudParameterizedMethod) {
            context.setPropertyResolved(true);
            return JsfCrudParameterizedMethod.class;
        } else if (base instanceof JsfCrudTransform) {
            if (property instanceof JsfCrudMethod) {
                context.setPropertyResolved(true);
                return JsfCrudTransform.class;
            }
            else {
                Class<?> result = ((JsfCrudTransform)base).getPropertyType(propertyName);
                context.setPropertyResolved(true);
                return result;
            }
        }
        
        return null;
    }
    
    /**
     * {@inheritDoc}
     */
    public Iterator<FeatureDescriptor> getFeatureDescriptors(ELContext context, Object base) {
        //todo: implement
        return null;
    }
    
    /**
     * {@inheritDoc}
     */
    public Class getCommonPropertyType(ELContext context,
                                                Object base) {
        if (context == null) {
            throw new NullPointerException();
        }
        
        if (base == null || base instanceof JsfCrudClass) {
            return String.class;
        } else if (base instanceof JsfCrudMethod) {
            JsfCrudMethod baseAsMethod = (JsfCrudMethod)base;
            if (baseAsMethod.getMethodName() == null) {
                return String.class;
            }
            else {
                return Object.class; //could be a param Object, JSFCRUD_NULL, or JSFCRUD_INVOKE
            }
        } else if (base instanceof JsfCrudParameterizedMethod) {
            return Object.class; //could be a param Object, JSFCRUD_NULL, or JSFCRUD_INVOKE
        } else if (base instanceof JsfCrudTransform) {
            JsfCrudTransform baseAsTransform = (JsfCrudTransform)base;
            boolean[] tma = baseAsTransform.transformMethodsAssigned;
            if (!tma[0] || !tma[1]) {
                return Object.class; //could be a JsfCrudMethod or JSFCRUD_NULL
            }
            else {
                return String.class; //the tailing propertyName
            }
        } else if (base != null) {
            return String.class;    //a catch-all
        }
        
        return null;
    }
    
    private class JsfCrudClass {
        private Class<?> type;
        public Class<?> getType() {
            return type;
        }
        public void setType(String typeName) {
            try {
                type = Class.forName(typeName);
            } catch (ClassNotFoundException e){
                throw new ELException(e);
            }
        }
        @Override
        public String toString() {
            return ""JsfCrudClass["" + type + ""]"";
        }
    }
    
    private class JsfCrudMethod {
        private Object base;    //can be an JsfCrudClass instance, or an arbitrary Object
        private String methodName;
        public JsfCrudMethod(Object base) {
            this.base = base;
        }
        public Object getBase() {
            return base;
        }
        public String getMethodName() {
            return methodName;
        }
        public void setMethodName(String methodName) {
            this.methodName = methodName;
        }
        @Override
        public String toString() {
            return ""JsfCrudMethod[base="" + base + "",methodName="" + methodName + ""]"";
        }
    }
    
    private class JsfCrudParameterizedMethod {
        private JsfCrudMethod method;
        private List<Object> actualParams;
        private Method methodToInvoke;
        
        public JsfCrudParameterizedMethod(JsfCrudMethod method) {
            this.method = method;
            actualParams = new ArrayList<Object>();
        }
        public JsfCrudMethod getMethod() {
            return method;
        }
        public void addParameter(Object param) {
            if (JsfCrudELResolver.JSFCRUD_NULL.equals(param)) {
                param = null;
            }
            actualParams.add(param);
        }
        @Override
        public String toString() {
            StringBuffer sb = new StringBuffer(""JsfCrudParameterizedMethod[method="");
            sb.append(method);
            sb.append("",params=List["");
            int i = 0;
            for (Object param : actualParams) {
                if (i > 0) {
                    sb.append("","");
                }
                sb.append(param);
                i++;
            }
            sb.append(""]]"");
            return sb.toString();
        }
        public Object invoke() {
            findMethodToInvoke();
            Object methodBase = method.getBase();
            Object instance = methodBase instanceof JsfCrudClass ? null : methodBase;
            Object[] paramArray = actualParams.toArray();
            try {
                return methodToInvoke.invoke(instance, paramArray);
            } catch (IllegalAccessException e) {
                throw new ELException(e);
            } catch (InvocationTargetException e) {
                throw new ELException(e);
            }
        }
        
        public Class<?> getReturnType() {
            findMethodToInvoke();
            return methodToInvoke.getReturnType();
        }
        
        private void findMethodToInvoke() {
            if (methodToInvoke != null) {
                return;
            }
            
            Object methodBase = method.getBase();
            JsfCrudClass staticMethodBase = null;
            if (methodBase instanceof JsfCrudClass) {
                staticMethodBase = (JsfCrudClass)methodBase;
            }
            Class<?> type;
            Method[] methodsOfType;
            if (staticMethodBase == null) {
                type = methodBase.getClass();
                methodsOfType = type.getMethods();
            }
            else {
                type = staticMethodBase.getType();
                methodsOfType = type.getDeclaredMethods();
            }
            methodsOfTypeLoop:
            for (Method methodOfType : methodsOfType) {
                String methodName = method.getMethodName();
                String methodOfTypeName = methodOfType.getName();
                if (!methodName.equals(methodOfTypeName)) {
                    continue;
                }
                if (staticMethodBase == null) {
                    if (Modifier.isStatic(methodOfType.getModifiers())) {
                        continue;
                    }
                }
                else {
                    if (!Modifier.isStatic(methodOfType.getModifiers())) {
                        continue;
                    }
                }
                Class<?>[] methodOfTypeFormalParams = methodOfType.getParameterTypes();
                if (methodOfTypeFormalParams.length != actualParams.size()) {
                    continue;
                }
                for (int i = 0; i < methodOfTypeFormalParams.length; i++) {
                    Object param = actualParams.get(i);
                    if (param == null) {
                        if (methodOfTypeFormalParams[i].isPrimitive()) {
                            continue methodsOfTypeLoop;
                        }
                    } else {
                        Class<?> paramType = param.getClass();
                        if (!methodOfTypeFormalParams[i].isAssignableFrom(paramType)) {
                            continue methodsOfTypeLoop;
                        }
                    }
                }
                methodToInvoke = methodOfType;
                break;
            }
            if (methodToInvoke == null) {
                throw new ELException(""could not find method to invoke; no appropriate method found in type "" +  type + "". JsfCrudParameterizedMethod was "" + this);
            }
        }
    }
    
    private class JsfCrudTransform {
        private Object base;
        private JsfCrudMethod[] transformMethods;
        private boolean[] transformMethodsAssigned;
        public JsfCrudTransform(Object base) {
            this.base = base;
            transformMethods = new JsfCrudMethod[2];
            transformMethodsAssigned = new boolean[2];
        }
        @Override
        public String toString() {
            StringBuffer sb = new StringBuffer();
            sb.append(""JsfCrudTransform=[base="");
            sb.append(base);
            sb.append("",transformMethod0="");
            sb.append(transformMethods[0]);
            sb.append("",transformMethod1="");
            sb.append(transformMethods[1]);
            sb.append("",transformMethodsAssigned0="");
            sb.append(transformMethodsAssigned[0]);
            sb.append("",transformMethodsAssigned1="");
            sb.append(transformMethodsAssigned[1]);
            sb.append(""]"");
            return sb.toString();
        }
        public Object getBase() {
            return base;
        }
        public void addMethod(JsfCrudMethod method) {
            if (!transformMethodsAssigned[0]) {
                transformMethods[0] = method;
                transformMethodsAssigned[0] = true;
            }
            else {
                if (transformMethodsAssigned[1]) {
                    throw new ELException(""attempt to add more than two methods to a JsfCrudTransform; additional JsfCrudMethod was "" + method);
                }
                transformMethods[1] = method;
                transformMethodsAssigned[1] = true;
            }
        }
        public void addNullMethod() {
            if (!transformMethodsAssigned[0]) {
                transformMethodsAssigned[0] = true;
            }
            else {
                if (transformMethodsAssigned[1]) {
                    throw new ELException(""attempt to add more than two methods to a JsfCrudTransform; additional JsfCrudMethod was null"");
                }
                transformMethodsAssigned[1] = true;
            }
        }
        public Class<?> getPropertyType(String propertyName) {
            if (transformMethods[0] == null) {
                PropertyDescriptor pd = getPropertyDescriptor(propertyName);
                return pd.getPropertyType();
            }
            JsfCrudParameterizedMethod parameterizedMethod = getParameterizedTransformationMethod(propertyName);
            return parameterizedMethod.getReturnType();
        }
        private Object getUntransformedProperty(String propertyName) {
            PropertyDescriptor pd = getPropertyDescriptor(propertyName);
            if (pd == null) {
                throw new ELException(""could not get untransformed property "" + propertyName + "" of base object "" + base + "": base object has no such property"");
            }
            Method readMethod = pd.getReadMethod();
            Object rawResult;
            try {
                rawResult = readMethod.invoke(base);
            } catch (IllegalAccessException e) {
                throw new ELException(e);
            } catch (InvocationTargetException e) {
                throw new ELException(e);
            } 
            return rawResult;
        }
        private JsfCrudParameterizedMethod getParameterizedTransformationMethod(String propertyName) {
            Object rawResult = getUntransformedProperty(propertyName);
            JsfCrudParameterizedMethod parameterizedMethod = new JsfCrudParameterizedMethod(transformMethods[0]);
            parameterizedMethod.addParameter(rawResult);
            return parameterizedMethod;
        }
        public Object getProperty(String propertyName) {
            if (transformMethods[0] == null) {
                return getUntransformedProperty(propertyName);
            }
            JsfCrudParameterizedMethod parameterizedMethod = getParameterizedTransformationMethod(propertyName);
            return parameterizedMethod.invoke();
        }
        public void setProperty(String propertyName, Object value) {
            PropertyDescriptor pd = getPropertyDescriptor(propertyName);
            if (pd == null) {
                throw new ELException(""could not set property "" + propertyName + "" of base object "" + base + "" with raw value "" + value + "": base object has no such property"");
            }
            Object transformedOrUntransformedValue = null;
            if (transformMethods[1] == null) {
                transformedOrUntransformedValue = value;
            }
            else {
                JsfCrudParameterizedMethod parameterizedMethod = new JsfCrudParameterizedMethod(transformMethods[1]);
                parameterizedMethod.addParameter(value);
                transformedOrUntransformedValue = parameterizedMethod.invoke();
            }
            Method writeMethod = pd.getWriteMethod();
            try {
                writeMethod.invoke(base, transformedOrUntransformedValue);
            } catch (IllegalAccessException e) {
                throw new ELException(e);
            } catch (InvocationTargetException e) {
                throw new ELException(e);
            }
        }
        private PropertyDescriptor getPropertyDescriptor(String propertyName) {
            Class<?> baseType = base.getClass();
            BeanInfo info;
            try {
                info = Introspector.getBeanInfo(baseType);
            } catch (IntrospectionException ie) {
                throw new ELException(ie);
            }
            for (PropertyDescriptor pd : info.getPropertyDescriptors()) {
                if (propertyName.equals(pd.getName())) {
                    return pd;
                }
            }
            return null;
        }
    }
}
"
-5955799332923500557,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\util\JsfUtil.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jsf.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.convert.Converter;
import javax.faces.model.SelectItem;

/**
 *
 * @author mbohm
 */
public class JsfUtil {
    
    public static SelectItem[] getSelectItems(List<?> entities, boolean selectOne) {
        int size = selectOne ? entities.size() + 1 : entities.size();
        SelectItem[] items = new SelectItem[size];
        int i = 0;
        if (selectOne) {
            items[0] = new SelectItem("""", ""---"");
            i++;
        }
        for (Object x : entities) {
            items[i++] = new SelectItem(x, x.toString());
        }
        return items;
    }
    
    public static void ensureAddErrorMessage(Exception ex, String defaultMsg) {
        String msg = ex.getLocalizedMessage();
        if (msg != null && msg.length() > 0) {
            addErrorMessage(msg);
        } else {
            addErrorMessage(defaultMsg);
        }
    }
    
    public static void addErrorMessages(List<String> messages) {
        for (String message : messages) {
            addErrorMessage(message);
        }
    }

    public static void addErrorMessage(String msg) {
        FacesMessage facesMsg = new FacesMessage(FacesMessage.SEVERITY_ERROR, msg, msg);
        FacesContext.getCurrentInstance().addMessage(null, facesMsg);
    }

    public static void addSuccessMessage(String msg) {
        FacesMessage facesMsg = new FacesMessage(FacesMessage.SEVERITY_INFO, msg, msg);
        FacesContext.getCurrentInstance().addMessage(""successInfo"", facesMsg);
    }
    
    public static String getRequestParameter(String key) {
        return FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap().get(key);
    }
    
    public static Object getObjectFromRequestParameter(String requestParameterName, Converter converter, UIComponent component) {
        String theId = JsfUtil.getRequestParameter(requestParameterName);
        return converter.getAsObject(FacesContext.getCurrentInstance(), component, theId);
    }
    
    public static <T> Collection<T> arrayToCollection(T[] arr) {
        if (arr == null) {
            return new ArrayList<T>();
        }
        return Arrays.asList(arr);
    }
    
    public static Object[] collectionToArray(Collection<?> c) {
        if (c == null) {
            return new Object[0];
        }
        return c.toArray();
    }
    
    public static String getAsConvertedString(Object object, Converter converter) {
        return converter.getAsString(FacesContext.getCurrentInstance(), null, object);
    }
    
    public static String getAsString(Object object) {
        if (object instanceof Collection<?>) {
            Collection<?> collection = (Collection<?>)object;
            if (collection.size() == 0) {
                return ""(No Items)"";
            }
            StringBuffer sb = new StringBuffer();
            int i = 0;
            for (Object item : collection) {
                if (i > 0) {
                    sb.append(""<br />"");
                }
                sb.append(item);
                i++;
            }
            return sb.toString();
        }
        return String.valueOf(object);
    }
}
"
5204797560037648036,F://JavaWorkspace//JsfJpaCrud\src\java\jsf\util\PagingInfo.java,"/*
 * Copyright (c) 2010, Oracle. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Oracle nor the names of its contributors
 *   may be used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jsf.util;

/**
 *
 * @author mbohm
 */
public class PagingInfo {
    private int batchSize = 5;
    private int firstItem = 0;
    private int itemCount = -1;
    
    public int getBatchSize() {
        return batchSize;
    }
    
    public int getItemCount() {
        return itemCount;
    }
    
    public void setItemCount(int itemCount) {
        this.itemCount = itemCount;
    }
    
    public int getFirstItem() {
        if (itemCount == -1) {
            throw new IllegalStateException(""itemCount must be set before invoking getFirstItem"");
        }
        if (firstItem >= itemCount) {
            if (itemCount == 0) {
                firstItem = 0;
            } else {
                int zeroBasedItemCount = itemCount - 1;
                double pageDouble = zeroBasedItemCount / batchSize;
                int page = (int) Math.floor(pageDouble);
                firstItem = page * batchSize;
            }
        }
        return firstItem;
    }
    
    public void setFirstItem(int firstItem) {
        this.firstItem = firstItem;
    }
    
    public int getLastItem() {
        getFirstItem();
        return firstItem + batchSize > itemCount ? itemCount : firstItem + batchSize;
    }
    
    public void nextPage() {
        getFirstItem();
        if (firstItem + batchSize < itemCount) {
            firstItem += batchSize;
        }
    }
    
    public void previousPage() {
        getFirstItem();
        firstItem -= batchSize;
        if (firstItem < 0) {
            firstItem = 0;
        }
    }
}
"
-4322227988604920208,F://JavaWorkspace//PythonGateway\src\AdditionApplication.java,"import py4j.GatewayServer;

public class AdditionApplication {

  public int addition(int first, int second) {
    return first + second;
  }

  public static void main(String[] args) {
    AdditionApplication app = new AdditionApplication();
    // app is now the gateway.entry_point
    GatewayServer server = new GatewayServer(app);
    server.start();
  }
}"
6572510923995563690,F://JavaWorkspace//PythonGateway\src\Code_Similarity.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.HashMap;
import java.util.List;

import py4j.GatewayServer;

/**
 *
 * @author NabeelShahid
 */
public class Code_Similarity {
	
    public static void main(String[] args) {
        GatewayServer gatewayServer = new GatewayServer(new Code_Similarity());
        gatewayServer.start();
        System.out.println(""Gateway Server Started"");
    }

    List<String> simpleName;
    HashMap<String, Integer> ast_Map;

    public Code_Similarity() {
    }

    public void run(String file_content1) {
        Similarity_Visitor av = Similarity_Visitor.parse_java_file(file_content1.toCharArray());
        simpleName = av.getSimpleName();
        ast_Map = av.getAST_Map();
    }

    public List<String> getSimpleName() {
        return simpleName;
    }

    public HashMap<String, Integer> getAst_Map() {
        return ast_Map;
    }

}
"
2836806166389484141,F://JavaWorkspace//PythonGateway\src\Similarity_Visitor.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;

import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.AnnotationTypeDeclaration;
import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;
import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;
import org.eclipse.jdt.core.dom.ArrayAccess;
import org.eclipse.jdt.core.dom.ArrayCreation;
import org.eclipse.jdt.core.dom.ArrayInitializer;
import org.eclipse.jdt.core.dom.ArrayType;
import org.eclipse.jdt.core.dom.AssertStatement;
import org.eclipse.jdt.core.dom.Assignment;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.BlockComment;
import org.eclipse.jdt.core.dom.BooleanLiteral;
import org.eclipse.jdt.core.dom.BreakStatement;
import org.eclipse.jdt.core.dom.CastExpression;
import org.eclipse.jdt.core.dom.CatchClause;
import org.eclipse.jdt.core.dom.CharacterLiteral;
import org.eclipse.jdt.core.dom.ClassInstanceCreation;
import org.eclipse.jdt.core.dom.Comment;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.ConditionalExpression;
import org.eclipse.jdt.core.dom.ConstructorInvocation;
import org.eclipse.jdt.core.dom.ContinueStatement;
import org.eclipse.jdt.core.dom.CreationReference;
import org.eclipse.jdt.core.dom.Dimension;
import org.eclipse.jdt.core.dom.DoStatement;
import org.eclipse.jdt.core.dom.EmptyStatement;
import org.eclipse.jdt.core.dom.EnhancedForStatement;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.ExportsDirective;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.ExpressionMethodReference;
import org.eclipse.jdt.core.dom.ExpressionStatement;
import org.eclipse.jdt.core.dom.FieldAccess;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ForStatement;
import org.eclipse.jdt.core.dom.IfStatement;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.InfixExpression;
import org.eclipse.jdt.core.dom.Initializer;
import org.eclipse.jdt.core.dom.InstanceofExpression;
import org.eclipse.jdt.core.dom.IntersectionType;
import org.eclipse.jdt.core.dom.Javadoc;
import org.eclipse.jdt.core.dom.LabeledStatement;
import org.eclipse.jdt.core.dom.LambdaExpression;
import org.eclipse.jdt.core.dom.LineComment;
import org.eclipse.jdt.core.dom.MarkerAnnotation;
import org.eclipse.jdt.core.dom.MemberRef;
import org.eclipse.jdt.core.dom.MemberValuePair;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.MethodRef;
import org.eclipse.jdt.core.dom.MethodRefParameter;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.ModuleDeclaration;
import org.eclipse.jdt.core.dom.ModuleModifier;
import org.eclipse.jdt.core.dom.NameQualifiedType;
import org.eclipse.jdt.core.dom.NormalAnnotation;
import org.eclipse.jdt.core.dom.NullLiteral;
import org.eclipse.jdt.core.dom.NumberLiteral;
import org.eclipse.jdt.core.dom.OpensDirective;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.ParameterizedType;
import org.eclipse.jdt.core.dom.ParenthesizedExpression;
import org.eclipse.jdt.core.dom.PostfixExpression;
import org.eclipse.jdt.core.dom.PrefixExpression;
import org.eclipse.jdt.core.dom.PrimitiveType;
import org.eclipse.jdt.core.dom.ProvidesDirective;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.QualifiedType;
import org.eclipse.jdt.core.dom.RequiresDirective;
import org.eclipse.jdt.core.dom.ReturnStatement;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SimpleType;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.StringLiteral;
import org.eclipse.jdt.core.dom.SuperConstructorInvocation;
import org.eclipse.jdt.core.dom.SuperFieldAccess;
import org.eclipse.jdt.core.dom.SuperMethodInvocation;
import org.eclipse.jdt.core.dom.SuperMethodReference;
import org.eclipse.jdt.core.dom.SwitchStatement;
import org.eclipse.jdt.core.dom.SwitchCase;
import org.eclipse.jdt.core.dom.SynchronizedStatement;
import org.eclipse.jdt.core.dom.TagElement;
import org.eclipse.jdt.core.dom.TextElement;
import org.eclipse.jdt.core.dom.ThisExpression;
import org.eclipse.jdt.core.dom.ThrowStatement;
import org.eclipse.jdt.core.dom.TryStatement;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.TypeDeclarationStatement;
import org.eclipse.jdt.core.dom.TypeLiteral;
import org.eclipse.jdt.core.dom.TypeMethodReference;
import org.eclipse.jdt.core.dom.TypeParameter;
import org.eclipse.jdt.core.dom.UnionType;
import org.eclipse.jdt.core.dom.UsesDirective;
import org.eclipse.jdt.core.dom.VariableDeclarationExpression;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;
import org.eclipse.jdt.core.dom.WhileStatement;
import org.eclipse.jdt.core.dom.WildcardType;

public class Similarity_Visitor extends ASTVisitor {

    private HashMap<String, Integer> AST_Map = new HashMap<>();
    private List<String> simpleName = new ArrayList<>();

    public static Similarity_Visitor parse_java_file(char[] file_content) {
        ASTParser parser = ASTParser.newParser(AST.JLS8);
        parser.setSource(file_content);
        final CompilationUnit cu;
        //IProgressMonitor monitor = null;
		cu = (CompilationUnit)  parser.createAST(null);//parser.createAST(null);

        // visit nodes of the constructed AST
        Similarity_Visitor visitor = new Similarity_Visitor();
        cu.accept(visitor);
        return visitor;
    }

    public HashMap<String, Integer> getAST_Map() {
        return AST_Map;
    }
    
    public List<String> getSimpleName() {
        return simpleName;
    }

    private boolean typeDic = false;

    private void add(String name, Object node) {
        String type = null;
        String content = node.toString().trim();
        Integer hash = content.hashCode();
        if (name != null) {
            type = name.substring(name.lastIndexOf('.') + 1);

            //to remove """" from string
            if (type.equals(""StringLiteral"")) {
                content = content.subSequence(1, content.length() - 1).toString().trim();
                hash = content.hashCode();
            }

            if (""IfStatement"".equals(type)) {
                IfStatement n = (IfStatement) node;
                this.addAST(type+"":-:""+""if("" + n.getExpression().toString() + "")"");
            }

            if (""MethodDeclaration"".equals(type)) {
                MethodDeclaration n = (MethodDeclaration) node;
                if (!simpleName.contains(content)) {
                    simpleName.add(n.getName().toString());
                }
                String para = Arrays.toString(n.parameters().toArray());
                para = para.substring(1, para.length() - 1);
                String x = null;

                String r;
                if (n.getReturnType2() == null) {
                    r = """";
                } else {
                    r = n.getReturnType2().toString();
                }
                x = r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";
                this.addAST(type+"":-:""+x);

                String modi = Arrays.toString(n.modifiers().toArray());
                modi = modi.replace(',', ' ');
                modi = modi.substring(1, modi.length() - 1);

                x = modi + "" ""
                        + r + "" ""
                        + n.getName().toString()
                        + ""("" + para + "")"";

                this.addAST(x);

                String exc = Arrays.toString(n.thrownExceptionTypes().toArray());
                exc = exc.replace(',', ' ');
                exc = exc.substring(1, exc.length() - 1);
                x = x + "" "" + exc;
                if (exc.length() != 0) {
                    this.addAST(x);
                }
            }

            if (type.contains(""Literal"")) {
                try {
                    Pattern.compile(""\\b"" + content + ""\\b"");
                } catch (Exception e) {
                    content = null;
                }
            }
            if (content != null && type.contains(""Literal"") || type.contains(""Name"") && typeDic) {
                if (!simpleName.contains(content)) {
                    simpleName.add(content);
                }
            }

            if (typeDic && content != null) {
                this.addAST(type+"":-:""+content);
            }
        }
    }

    public Map<CharSequence, Integer> normaliz() {
        Map<CharSequence, Integer> temp = new HashMap<>();
//        temp.putAll(this.AST_Map);
        for (Iterator i = AST_Map.keySet().iterator(); i.hasNext();) {
            String line = i.next().toString();
            String allChange = line;
            String newLine = null;
                   
            for (String sn : simpleName) {
                if (line.contains(sn)) {
                    allChange = allChange.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    newLine = line.replaceAll(""\\b"" + sn + ""\\b"", "" NAME"").trim();
                    if (!newLine.equals(line)) {
                        if (!temp.containsKey(newLine)) {
                            temp.put(newLine, 1);
                        } else {
                            temp.put(newLine, temp.get(newLine) + 1);
                        }
                    }
                }
            }
            if (!line.equals(allChange) && !allChange.equals(newLine)) {
                if (!temp.containsKey(allChange)) {
                    temp.put(allChange, 1);
                } else {
                    temp.put(allChange, temp.get(allChange) + 1);
                }
            }
        }
        return temp;
    }

    private void addAST(String x) {
        x = x.trim();
        if (!this.AST_Map.containsKey(x)) {
            this.AST_Map.put(x, 1);
        } else {
            this.AST_Map.put(x, this.AST_Map.get(x) + 1);
        }
    }

    @Override
    public boolean visit(CompilationUnit node) {
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclaration node) {
        this.typeDic = true;
        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodDeclaration node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(ForStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(IfStatement node) {
        add(node.getClass().getName(), node);

        return true;
    }

    @Override
    public boolean visit(SwitchStatement node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SwitchCase node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WhileStatement node) {
        add(""while ("" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LambdaExpression node) {
        add(node.getClass().getName(), node);

        return true;
    }

    public boolean visit(Comment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayAccess node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Block node) {
        // 
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeDeclaration node) {
        //     
//        add(node.getClass().getName(),node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AnnotationTypeMemberDeclaration node) {
        //   
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(AnonymousClassDeclaration node) {
        // 
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayCreation node) {
        //
        add(node.getClass().getName(), node);
        return true;

    }

    @Override
    public boolean visit(ArrayInitializer node) {
        //     
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ArrayType node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(AssertStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Assignment node) {
        //   
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BlockComment node) {
        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BooleanLiteral node) {
        //  
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(BreakStatement node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CastExpression node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CatchClause node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CharacterLiteral node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ClassInstanceCreation node) {
        // 
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConditionalExpression node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ConstructorInvocation node) {
        //
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ContinueStatement node) {

        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(CreationReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Dimension node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(DoStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EmptyStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnhancedForStatement node) {
        add(""for("" + node.getParameter().toString() + "" : "" + node.getExpression().toString() + "")"", node);
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumConstantDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(EnumDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExportsDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ExpressionStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(FieldDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ImportDeclaration node) {
        //  add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Initializer node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(InstanceofExpression node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(IntersectionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Javadoc node) {
        //System.out.println(node);
//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LabeledStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(LineComment node) {

        //    add(node.getClass().getName(), node);
        //   System.out.println(node.toString());
        return true;
    }

    @Override
    public boolean visit(MarkerAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberRef node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MemberValuePair node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRef node) {

//        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodRefParameter node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(MethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(Modifier node) {

        //   add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ModuleModifier node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NameQualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NormalAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NullLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(NumberLiteral node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(OpensDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PackageDeclaration node) {

        //      add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParameterizedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ParenthesizedExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PostfixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrefixExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ProvidesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(PrimitiveType node) {

        //add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedName node) {

        // add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(QualifiedType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(RequiresDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ReturnStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleName node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SimpleType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleMemberAnnotation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SingleVariableDeclaration node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(StringLiteral node) {
        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperConstructorInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperFieldAccess node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodInvocation node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SuperMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(SynchronizedStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TagElement node) {

        //     add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TextElement node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThisExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(ThrowStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TryStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeLiteral node) {

        //    add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeMethodReference node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(TypeParameter node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UnionType node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(UsesDirective node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationExpression node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationStatement node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(VariableDeclarationFragment node) {

        add(node.getClass().getName(), node);
        return true;
    }

    @Override
    public boolean visit(WildcardType node) {

        add(node.getClass().getName(), node);
        return true;
    }
}
"
5297961009566863534,F://JavaWorkspace//PythonGateway\src\Test.java,"
public class Test {

	public static void main(String[] args) {
		System.out.print(""Test"");
	}

}
"
-3524534451102567608,F://JavaWorkspace//PythonGateway\src\py4j\test\ExampleListener.java,"// py4j/examples/ExampleListener.java
package py4j.test;

public interface ExampleListener {

    Object notify(Object source);

}"
2814991481494865560,F://JavaWorkspace//PythonGateway\src\py4j\test\ListenerApplication.java,"package py4j.test;

import py4j.GatewayServer;

import java.util.ArrayList;
import java.util.List;

public class ListenerApplication {

    List<ExampleListener> listeners = new ArrayList<ExampleListener>();

    public void registerListener(ExampleListener listener) {
        listeners.add(listener);
    }

    public void notifyAllListeners() {
        for (ExampleListener listener: listeners) {
            Object returnValue = listener.notify(this);
            System.out.println(returnValue);
        }
    }

    @Override
    public String toString() {
        return ""<ListenerApplication> instance"";
    }

    public static void main(String[] args) {
        ListenerApplication application = new ListenerApplication();
        GatewayServer server = new GatewayServer(application);
        server.start(true);
    }
}"
-8417500734896840271,F://JavaWorkspace//PythonGateway\src\py4j\test\Stack.java,"package py4j.test;

import java.util.LinkedList;
import java.util.List;

public class Stack {
    private List<String> internalList = new LinkedList<String>();

    public void push(String element) {
        internalList.add(0, element);
    }

    public String pop() {
        return internalList.remove(0);
    }

    public List<String> getInternalList() {
        return internalList;
    }

    public void pushAll(List<String> elements) {
        for (String element : elements) {
            this.push(element);
        }
    }
}"
150410659066372679,F://JavaWorkspace//PythonGateway\src\py4j\test\StackEntryPoint.java,"package py4j.test;

import py4j.GatewayServer;

public class StackEntryPoint {

    private Stack stack;

    public StackEntryPoint() {
      stack = new Stack();
      stack.push(""Initial Item"");
    }

    public Stack getStack() {
        return stack;
    }

    public static void main(String[] args) {
        GatewayServer gatewayServer = new GatewayServer(new StackEntryPoint());
        gatewayServer.start();
        System.out.println(""Gateway Server Started"");
    }
}"
7353242258208019974,F://JavaWorkspace//Test\src\main\java\Test.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import javax.inject.Named;
import javax.enterprise.context.Dependent;

/**
 *
 * @author NabeelKhan
 */
@Named(value = ""test"")
@Dependent
public class Test {

    /**
     * Creates a new instance of Test
     */
    public Test() {
    }
    
}
"
-2844234733779621992,F://JavaWorkspace//Thrade\src\carrace\Car.java,"package carrace;

public class Car implements Runnable {

	private Person person;
	private String carName;
	private double distance_coverd;
	private static boolean win = true;

	public Car(String carName, String driver) {
		this.person = new Person(driver);
		this.carName = carName;
	}

	@Override
	public void run() {
		while (!Race.isFinish()) {
			this.drive(Math.random() * ((100 - 1) + 1) + 1);
			if (this.getDistCoverd() >= Race.getLap_length()) {
				Race.setWinner(this.toString());
				Race.setFinish(true);
			}
			System.err.println(this.toString());
		}
		if(Race.getWinner() != null && Car.win) {
			Car.win = false;
			System.out.println(
					""\n===============================\n""+
					Race.getWinner()+""\n""+
					""===============================\n"");
		}
	}

	public void drive(double speed) {
		this.distance_coverd += (speed * Race.getTime());
		Race.incTime();
	}

	public double getDistCoverd() {
		return distance_coverd;
	}

	public Person getPerson() {
		return person;
	}

	public String toString() {
		return person.getName() + ""-"" + carName + "" "" + String.format(""%.2f"", distance_coverd) + ""Km"";
	}

	public class Person {

		String name;
		int start = 0;
		int stop;
		float rest_interval;

		Person(String name) {
			this.name = name;
			rest_interval = stop - start;
		}

		public String getName() {
			return name;
		}

	}
}
"
4748111614853626777,F://JavaWorkspace//Thrade\src\carrace\Main.java,"/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package carrace;

public class Main {
	public static void main(String[] args) {

		Race.setLap_length(1000);
		
		Car car1 = new Car(""Volvo"", ""Jon"");
		Car car2 = new Car(""Audi"", ""Max"");
		Car car3 = new Car(""Toyota"", ""Alan"");
		Car car4 = new Car(""Honda"", ""Sam"");

		Race race = new Race();
		race.addCar(car1);
		race.addCar(car2);
		race.addCar(car3);
		race.addCar(car4);
		race.Go();	
	
	}
}
"
1146651578173541262,F://JavaWorkspace//Thrade\src\carrace\Race.java,"package carrace;

import java.util.ArrayList;
import java.util.List;

public class Race {

	private List<Car> carList = new ArrayList<Car>();
	private static String winner;
	private static int lap_length;
	private static int time;
	private static boolean finish = false;
	
	public void Go() {
		for (Car c : carList) {
			Thread t = new Thread(c);
			t.start();			
		}
	}

	public void addCar(Car car) {
		this.carList.add(car);
	}

	public static String getWinner() {
		return winner;
	}

	public static void setWinner(String winner) {
		Race.winner = winner;
	}

	public static int getLap_length() {
		return lap_length;
	}

	public static void setLap_length(int lap_length) {
		Race.lap_length = lap_length;
	}

	public static boolean isFinish() {
		return finish;
	}

	public static void setFinish(boolean finish) {
		Race.finish = finish;
	}

	public static int getTime() {
		return time;
	}

	public static void incTime() {
		Race.time += 1;
	}	
	
}
"
